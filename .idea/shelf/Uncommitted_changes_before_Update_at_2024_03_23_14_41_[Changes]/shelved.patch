Index: Chunithm-AllInOne-ESP32/Chunithm-AllInOne-ESP32.ino
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <WiFi.h>\r\n#include <WebServer.h>\r\n#include <EEPROM.h>\r\n#include <U8g2lib.h>\r\n#include <Adafruit_DS3502.h>\r\n#include <Adafruit_NeoPixel.h>\r\n#include <FastLED.h>\r\n#include <SoftwareSerial.h>\r\n#include <IRremote.hpp>\r\n#include <HTTPClient.h>\r\n#include \"melody.h\"\r\n\r\nconst char* ssid = \"Radio Noise AX\";\r\nconst char* password = \"Radio Noise AX\";\r\nWebServer server(80);\r\n\r\n// ETHERNET PHY DIGITAL SWITCH\r\n// WACCA \"0\" - PURPLE RED ZIP TIE (Sensor) WHITE (SELECT)\r\n// CHUNI \"1\" - PURPLE BLUE ZIP TIE (Sensor) WHITE (SELECT)\r\nconst int numOfethPorts = 2;\r\nconst int ethSensors[2] = { 35, 34 };\r\nconst int ethButtons[2] = { 18, 19 };\r\n// Nu CONTROL PORT (KEYCHIP REPLACEMENT)\r\n// UART Serial to Arduino Nano\r\nEspSoftwareSerial::UART nuControl;\r\nconst int nuControlTX = 15; // WHITE RED\r\nconst int nuControlRX = 5; // WHITE GREEN\r\nString nuResponse = \"\";\r\n// Power Controls\r\n// 0 - PSU and Monitor Enable\r\n// 1 - Nu Power Enable\r\n// 2 - Marquee Enable\r\n// 3 - LED Select\r\n// 4 - Slider RS232\r\nconst int numberRelays = 5;\r\nconst int controlRelays[5] = { 12, 14, 27, 26, 25 };\r\n// Fan Controller\r\nconst int fanPWM = 13;\r\n// Card Reader Communication\r\nHardwareSerial cardReaderSerial(2);\r\nbool coinEnable = false;\r\nbool allsOK = false;\r\nbool has_cr_talked = false;\r\n// Display Switch\r\n// 23 - Select\r\n// 15 - State\r\nconst int displayMainSelect = 23;\r\nconst int displayMainLDR = 36;\r\nbool displayMainState = false;\r\n// Chunithm LED Driver\r\n#define LED_PIN_1 32  // Define the data pin for the first LED strip\r\n#define LED_PIN_2 33  // Define the data pin for the second LED strip\r\n#define NUM_LEDS_1 53  // Number of LEDs in each strip\r\n#define NUM_LEDS_2 63  // Number of LEDs in each strip\r\nCRGB leds1[NUM_LEDS_1];  // Define the LED array for the first strip\r\nCRGB leds2[NUM_LEDS_2];  // Define the LED array for the second strip\r\nCRGB leds1_source[NUM_LEDS_1];  // Define the LED array for the first strip\r\nCRGB leds2_source[NUM_LEDS_2];  // Define the LED array for the second strip\r\nCRGB leds1_target[NUM_LEDS_1];  // Define the LED array for the first strip\r\nCRGB leds2_target[NUM_LEDS_2];  // Define the LED array for the second strip\r\nCRGB leds1_backup[NUM_LEDS_1];  // Define the LED array for the first strip\r\nCRGB leds2_backup[NUM_LEDS_2];  // Define the LED array for the second strip\r\nAdafruit_NeoPixel NeoPixelL(NUM_LEDS_1, LED_PIN_1, NEO_RGB + NEO_KHZ800);\r\nAdafruit_NeoPixel NeoPixelR(NUM_LEDS_2, LED_PIN_2, NEO_RGB + NEO_KHZ800);\r\nuint8_t sourceBrightness = 0;\r\nuint8_t targetBrightness = 0;\r\nunsigned long previousMillis = 0;\r\nuint8_t numSteps = 33; // Number of steps in the transition\r\nuint8_t currentStep = 0;\r\nbool pending_release_leds = false;\r\nbool pending_release_display = false;\r\nbool pending_alls_good_response = false;\r\nbool transition_leds = false;\r\nfloat transition_interval = 0;\r\nint animation_mode = -1;\r\nint animation_state = -1;\r\n// Beeper Tones\r\nint buzzer_pin = 4;\r\nunsigned long previousMelodyMillis = 0;\r\nint currentNote = 0;\r\nint melodyPlay = -1;\r\nbool startMelody = false;\r\nint loopMelody = -1;\r\nint pauseBetweenNotes = 0;\r\nint booting_tone[] = {\r\n  NOTE_C5, NOTE_E5, NOTE_D5, NOTE_C6, NOTE_E6\r\n};\r\nint booting_tone_dur[] = {\r\n  8, 8, 8, 4, 2\r\n};\r\n\r\nint shutting_down_tone[] = {\r\n  NOTE_D5, NOTE_A4, NOTE_D5, NOTE_D4\r\n};\r\nint shutting_down_dur[] = {\r\n  8, 8, 4, 2\r\n};\r\nint warning_tone[] = {\r\n  NOTE_A5, NOTE_G5, NOTE_F5\r\n};\r\nint warning_tone_dur[] = {\r\n  8, 8, 8\r\n};\r\nint warning_tone_long[] = {\r\n  NOTE_A5, NOTE_F5\r\n};\r\nint warning_tone_long_dur[] = {\r\n  4, 4\r\n};\r\nint boot_tone[] = {\r\n  NOTE_F5, NOTE_G5, NOTE_A5, NOTE_B5\r\n};\r\nint boot_tone_dur[] = {\r\n  8, 8, 8, 4\r\n};\r\n// IR Recever\r\nconst int irRecPin = 2;\r\n// Occupancy and Timer\r\nint requestedPowerState0 = -1;\r\nint defaultInactivityMinTimeout = 45;\r\nint inactivityMinTimeout = 45;\r\nconst int shutdownDelayMinTimeout = 5;\r\nunsigned long previousInactivityMillis = 0;\r\nunsigned long previousShutdownMillis = 0;\r\nbool inactivityTimeout = false;\r\n\r\nconst int nuPostCooldownMinTimeout = 5;\r\nconst int allsPostCooldownMinTimeout = 10;\r\nint previousCooldownMillis = 0;\r\nint activeCooldownTimer = -1;\r\n\r\n// DISPLAY_MESSAGE::BIG::icon::text::isJP/t::255::invert/t::timeout/20\r\nint typeOfMessage = -1;\r\nint messageIcon = 0;\r\nString messageText = \"\";\r\nbool isJpnMessage = false;\r\nint brightMessage = 1;\r\nbool invertMessage = false;\r\nint timeoutMessage = 0;\r\n\r\nbool ready_to_boot = false;\r\nString inputString = \"\";\r\nString attachedSoftwareCU = \"Unknown\";\r\nint currentVolume = 0;\r\nbool muteVolume = false;\r\nint minimumVolume = 20;\r\nint maximumVolume = 127;\r\nbool inhibitNuState = false;\r\nint currentGameSelected0 = -1;\r\nint currentNuPowerState0 = -1;\r\nint currentALLSState0 = -1;\r\nint currentPowerState0 = -1;\r\nint currentLEDState = 0;\r\nint currentSliderState = 0;\r\nint currentMarqueeState = 1;\r\nint currentFanSpeed = 128;\r\nint displayedSec = 0;\r\nint refresh_time = 0;\r\nint displayState = -1;\r\nU8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0);\r\nAdafruit_DS3502 ds3502 = Adafruit_DS3502();\r\nTaskHandle_t Task1;\r\nTaskHandle_t Task2;\r\nTaskHandle_t Task3;\r\nTaskHandle_t Task4;\r\nTaskHandle_t Task5;\r\nTaskHandle_t Task6;\r\nTaskHandle_t Task7;\r\nTaskHandle_t Task8;\r\nTaskHandle_t Task9;\r\n\r\nString remoteLEDTrigger = \"http://192.168.100.62:3001/button-streamdeck2?event=long-press\";\r\n\r\nvoid checkWiFiConnection() {\r\n  if (WiFi.status() != WL_CONNECTED) {\r\n    WiFi.hostname(\"CabinetManager\");\r\n    WiFi.disconnect(true);\r\n    WiFi.begin(ssid, password);\r\n    WiFi.setAutoReconnect(true);\r\n    WiFi.persistent(true);\r\n    tone(buzzer_pin, NOTE_CS5, 1000 / 8);\r\n    int tryCount = 0;\r\n    while (WiFi.status() != WL_CONNECTED) {\r\n      //if (tryCount > 60 && currentPowerState0 != 1) {\r\n      //  ESP.restart();\r\n      //}\r\n      tone(buzzer_pin, (tryCount % 2 == 0) ? NOTE_GS5 : NOTE_CS5, 1000 / 8);\r\n      delay(500);\r\n      tryCount++;\r\n    }\r\n    noTone(buzzer_pin);\r\n  }\r\n}\r\n\r\nvoid setup() {\r\n  pinMode(displayMainSelect, OUTPUT);\r\n  digitalWrite(displayMainSelect, HIGH);\r\n  inputString.reserve(200);\r\n  attachedSoftwareCU.reserve(200);\r\n  Serial.begin(115200);\r\n  u8g2.begin();\r\n  u8g2.enableUTF8Print();\r\n  bootScreen(\"HARDWARE\");\r\n  pinMode(fanPWM, OUTPUT);\r\n  pinMode(displayMainLDR, INPUT);\r\n  for (int i=0; i < numberRelays; i++) {\r\n    pinMode(controlRelays[i], OUTPUT);\r\n    digitalWrite(controlRelays[i], LOW);\r\n  }\r\n  for (int i=0; i < numOfethPorts; i++) {\r\n    pinMode(ethButtons[i], OUTPUT);\r\n    digitalWrite(ethButtons[i], HIGH);\r\n    pinMode(ethSensors[i], INPUT);\r\n\r\n    if (digitalRead(ethSensors[i]) == HIGH) {\r\n      digitalWrite(ethButtons[i], LOW);\r\n      delay(150);\r\n      digitalWrite(ethButtons[i], HIGH);\r\n    }\r\n  }\r\n  if (!ds3502.begin()) {\r\n    bootScreen(\"I2C VOL FAILURE\");\r\n    while (1);\r\n  }\r\n  NeoPixelL.begin();\r\n  NeoPixelR.begin();\r\n  NeoPixelL.show();\r\n  NeoPixelR.show();\r\n  NeoPixelL.setBrightness(255);\r\n  NeoPixelR.setBrightness(255);\r\n  IrReceiver.begin(irRecPin);\r\n\r\n  tone(buzzer_pin, NOTE_C6);\r\n  bootScreen(\"NU_CTRL_COM\");\r\n  nuControl.begin(9600, SWSERIAL_8N1, nuControlRX, nuControlTX, false);\r\n  if (!nuControl) {\r\n    bootScreen(\"NU_COM_FAIL\");\r\n    while (1) { // Don't continue with invalid configuration\r\n      delay (1000);\r\n    }\r\n  }\r\n  xTaskCreatePinnedToCore(\r\n                  nuControlRXLoop,   /* Task function. */\r\n                  \"nuControlRX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task6,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  while (nuResponse.substring(0,1) != \"P\") {\r\n    delay(500);\r\n    nuControl.println(\"P::\");\r\n  }\r\n  while (nuResponse == \"\") {\r\n    nuControl.println(\"PS::0\");\r\n    delay(100);\r\n  }\r\n  nuResponse = \"\";\r\n\r\n  bootScreen(\"PC_LINK\");\r\n  xTaskCreatePinnedToCore(\r\n                    pingLoop,   /* Task function. */\r\n                    \"pingTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    1,           /* priority of the task */\r\n                    &Task3,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  kioskTest();\r\n\r\n  bootScreen(\"CARD_LINK\");\r\n  cardReaderSerial.begin(9600, SERIAL_8N1, 16, 17);\r\n  if (!cardReaderSerial) {\r\n    bootScreen(\"CARDREADER_FAIL_1\");\r\n    while (1) { // Don't continue with invalid configuration\r\n      delay (1000);\r\n    }\r\n  }\r\n  noTone(buzzer_pin);\r\n  delay(500);\r\n\r\n  bootScreen(\"NETWORK\");\r\n  checkWiFiConnection();\r\n\r\n  tone(buzzer_pin, NOTE_C6);\r\n  bootScreen(\"RST_READER\");\r\n  for (int i = 0; i < 3; i++) {\r\n    cardReaderSerial.println(\"REBOOT::NO_DATA\");\r\n    delay(100);\r\n  }\r\n  testCardReader();\r\n  noTone(buzzer_pin);\r\n\r\n\r\n  bootScreen(\"DEFAULTS\");\r\n  currentVolume = map(25, 0, 100, minimumVolume, maximumVolume);\r\n  ds3502.setWiper(currentVolume);\r\n  ds3502.setWiperDefault(currentVolume);\r\n  displayMainState = (digitalRead(displayMainLDR) == LOW);\r\n  kioskModeRequest(\"StopAll\");\r\n  Serial.println(\"LED_DATA::16::0::000000::\");\r\n  setChassisFanSpeed(40);\r\n  delay(2000);\r\n\r\n  bootScreen(\"REMOTE_ACCESS\");\r\n  server.on(\"/volume/set\", [=]() {\r\n    int _currentVolume = currentVolume;\r\n    if (server.hasArg(\"wiper\")) {\r\n      int _volVal = server.arg(\"wiper\").toInt();\r\n      if (_volVal > 0 && _volVal <= 127) {\r\n        currentVolume = _volVal;\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(currentVolume));\r\n      }\r\n    } else if (server.hasArg(\"down\")) {\r\n      int _volVal = server.arg(\"down\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        current_percent -= _volVal;\r\n        currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(current_percent));\r\n      }\r\n    } else if (server.hasArg(\"up\")) {\r\n      int _volVal = server.arg(\"up\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        current_percent += _volVal;\r\n        currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(current_percent));\r\n      }\r\n    } else if (server.hasArg(\"percent\")) {\r\n      int _volVal = server.arg(\"percent\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        currentVolume = map(_volVal, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(_volVal));\r\n      }\r\n    } else if (server.hasArg(\"mute\")) {\r\n      String _muteVal = server.arg(\"mute\");\r\n      if (server.hasArg(\"invert\")) {\r\n        muteVolume = (_muteVal != \"true\");\r\n        server.send(200, \"text/plain\", \"OK\");\r\n      } else {\r\n        muteVolume = (_muteVal == \"true\");\r\n        server.send(200, \"text/plain\", \"OK\");\r\n      }\r\n    }\r\n    ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n    if (_currentVolume != currentVolume) {\r\n      displayVolumeMessage();\r\n    }\r\n  });\r\n  server.on(\"/volume\", [=]() {\r\n    String response = \"\";\r\n    if (server.hasArg(\"mute\")) {\r\n      if (server.hasArg(\"invert\")) {\r\n        response += ((muteVolume == true) ? \"0\" : \"1\");\r\n      } else {\r\n        response += ((muteVolume == true) ? \"1\" : \"0\");\r\n      }\r\n    } else {\r\n      response += map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/set\", [=]() {\r\n    String response = \"UNCHANGED\";\r\n    int fanSpeed = -1;\r\n    if (server.hasArg(\"percent\")) {\r\n      int _fanVal = server.arg(\"percent\").toInt();\r\n      if (_fanVal > 0 && _fanVal <= 100) {\r\n        fanSpeed = _fanVal;\r\n        response = \"SET TO \";\r\n        response += _fanVal;\r\n        response += \"%\";\r\n      }\r\n    }\r\n    if (fanSpeed > -1) {\r\n      setChassisFanSpeed(fanSpeed);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/reset\", [=]() {\r\n    String response = \"OK\";\r\n    if (currentPowerState0 == 0) {\r\n      setChassisFanSpeed(50);\r\n    } else if (currentPowerState0 == -1) {\r\n      setChassisFanSpeed(30);\r\n    } else if (currentPowerState0 == 1) {\r\n      setChassisFanSpeed((currentGameSelected0 < 10) ? 75 : 100);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n\r\n  server.on(\"/fan\", [=]() {\r\n    String response = \"\";\r\n    response += map(currentFanSpeed, 0, 255, 0, 100);\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n\r\n  server.on(\"/display/pc\", [=]() {\r\n    setDisplayState(true);\r\n    server.send(200, \"text/plain\", (displayMainSelect == true) ? \"UNCHANGED\" : \"OK\");\r\n  });\r\n  server.on(\"/display/game\", [=]() {\r\n    setDisplayState(false);\r\n    server.send(200, \"text/plain\", (displayMainSelect == false) ? \"UNCHANGED\" : \"OK\");\r\n  });\r\n  server.on(\"/display/switch\", [=]() {\r\n    String assembledOutput = \"\";\r\n    pushDisplaySwitch();\r\n    assembledOutput += ((displayMainSelect == false) ? \"PC\" : \"AUX\");\r\n    server.send(200, \"text/plain\", assembledOutput);\r\n  });\r\n  server.on(\"/display\", [=]() {\r\n    String assembledOutput = \"\";\r\n    assembledOutput += ((displayMainSelect == true) ? \"PC\" : \"GAME\");\r\n    server.send(200, \"text/plain\", assembledOutput);\r\n  });\r\n\r\n  server.on(\"/network/set/all\", [=]() {\r\n    for (int i=0; i < server.args(); i++) {\r\n      if (server.argName(i) == \"ethNum\") {\r\n        const String ethVal = server.arg(i);\r\n        for (int o=0; o < numOfethPorts; o++) {\r\n          if (digitalRead(ethSensors[o]) == (ethVal[o] == '1' ? LOW : HIGH)) {\r\n            if (o == 1 && currentPowerState0 == 1) {\r\n              nuControl.println(\"PS::128\");\r\n              if (pending_release_display == false) {\r\n                setDisplayState(true);\r\n                startLoadingScreen();\r\n              }\r\n            }\r\n            pushEthSwitch(o);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n  });\r\n  server.on(\"/network/set\", [=]() {\r\n    String assembledOutput = \"\";\r\n    int ethNum = 0;\r\n    int ethVal = 0;\r\n    for (int i=0; i < server.args(); i++) {\r\n      if (server.argName(i) == \"cabNum\")\r\n        ethNum = server.arg(i).toInt();\r\n      else if (server.argName(i) == \"ethNum\")\r\n        ethVal = server.arg(i).toInt();\r\n    }\r\n    if (digitalRead(ethSensors[ethNum]) == ((ethVal == 1) ? LOW : HIGH)) {\r\n      setEthernetState(ethNum, ethVal);\r\n      server.send(200, \"text/plain\", (ethNum == 0 && currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/network\", [=]() {\r\n    String assembledOutput = \"\";\r\n    int ethNum = 0;\r\n    for (int i=0; i < server.args(); i++) {\r\n      if (server.argName(i) == \"cabNum\") {\r\n        ethNum = server.arg(i).toInt();\r\n        if (ethNum == 0 && currentGameSelected0 >= 10) {\r\n          assembledOutput += \"Private\";\r\n        } else {\r\n          String const val = getEthSwitchVal(ethNum);\r\n          assembledOutput += val;\r\n        }\r\n      }\r\n    }\r\n    server.send(200, \"text/plain\", assembledOutput);\r\n  });\r\n\r\n  server.on(\"/select/game/omni\", [=]() {\r\n    if (currentGameSelected0 != 0) {\r\n      setGameDisk(0);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/base\", [=]() {\r\n    if (currentGameSelected0 != 1) {\r\n      setGameDisk(1);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/air\", [=]() {\r\n    if (currentGameSelected0 != 2) {\r\n      setGameDisk(2);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/star\", [=]() {\r\n    if (currentGameSelected0 != 3) {\r\n      setGameDisk(3);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/crystal\", [=]() {\r\n    if (currentGameSelected0 != 4) {\r\n      setGameDisk(4);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/other\", [=]() {\r\n    if (currentGameSelected0 != 5) {\r\n      setGameDisk(5);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/pdft\", [=]() {\r\n    if (currentGameSelected0 != 20) {\r\n      setGameDisk(20);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/sun\", [=]() {\r\n    if (currentGameSelected0 != 10) {\r\n      setGameDisk(10);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/new\", [=]() {\r\n    if (currentGameSelected0 != 11) {\r\n      setGameDisk(11);\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game\", [=]() {\r\n    String const val = getGameSelect();\r\n    server.send(200, \"text/plain\", val);\r\n  });\r\n\r\n  server.on(\"/sys_board\", [=]() {\r\n    server.send(200, \"text/plain\", (currentGameSelected0 >= 10) ? \"ALLS MX2\" : \"Nu 1.1\");\r\n  });\r\n\r\n  server.on(\"/power/off\", [=]() {\r\n    server.send(200, \"text/plain\", (currentPowerState0 == -1) ? \"UNCHNAGED\" : \"OK\");\r\n    setMasterPowerOff();\r\n    currentPowerState0 = -1;\r\n  });\r\n  server.on(\"/power/standby\", [=]() {\r\n    if (currentPowerState0 == 1) {\r\n      setGameOff();\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else if (currentPowerState0 == -1) {\r\n      setMasterPowerOn();\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/power/on\", [=]() {\r\n    server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"UNCHNAGED\" : \"OK\");\r\n    setGameOn();\r\n  });\r\n  server.on(\"/request/standby\", [=]() {\r\n    server.send(200, \"text/plain\", \"OK\");\r\n    if (currentPowerState0 == 1 && (coinEnable == true || currentGameSelected0 > 19)) {\r\n      if (server.hasArg(\"nonauthoritive\")) {\r\n      } else {\r\n        shuttingDownLEDState(1);\r\n      }\r\n    } else if (currentPowerState0 == 1 && coinEnable == false) {\r\n      if (server.hasArg(\"nonauthoritive\")) {\r\n      } else {\r\n        setGameOff();\r\n      }\r\n    } else if (currentPowerState0 == -1) {\r\n      setMasterPowerOn();\r\n    }\r\n  });\r\n  server.on(\"/request/off\", [=]() {\r\n    server.send(200, \"text/plain\", \"OK\");\r\n    requestPowerOff();\r\n  });\r\n\r\n  server.on(\"/test/nu/off\", [=]() {\r\n    nuResponse = \"\";\r\n    while (currentNuPowerState0 == 1) {\r\n      nuControl.println(\"PS::0\");\r\n      delay(100);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/nu/on\", [=]() {\r\n    nuResponse = \"\";\r\n    while (currentNuPowerState0 == 0) {\r\n      nuControl.println(\"PS::1\");\r\n      delay(100);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/nu/reset\", [=]() {\r\n    nuResponse = \"\";\r\n    while (nuResponse == \"\") {\r\n      nuControl.println(\"PS::128\");\r\n      delay(100);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/off\", [=]() {\r\n    //setDisplayState(true);\r\n    setSysBoardPower(false);\r\n    setTouchControl(false);\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/on\", [=]() {\r\n    //setDisplayState(false);\r\n    setSysBoardPower(true);\r\n    setTouchControl((currentGameSelected0 < 10));\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/reset\", [=]() {\r\n    //setDisplayState(false);\r\n    setSysBoardPower(true);\r\n    setTouchControl(currentGameSelected0 < 10);\r\n    if (currentGameSelected0 >= 10) {\r\n      ALLSCtrl(\"PS\", \"128\");\r\n    } else {\r\n      nuResponse = \"\";\r\n      while (nuResponse == \"\") {\r\n        nuControl.println(\"PS::128\");\r\n        delay(100);\r\n      }\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/display_switch/hold\", [=]() {\r\n    digitalWrite(displayMainSelect, HIGH);\r\n    digitalWrite(displayMainSelect, LOW);\r\n    delay(5000);\r\n    digitalWrite(displayMainSelect, HIGH);\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/melody\", [=]() {\r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/display\", [=]() {\r\n    messageIcon = 223;\r\n    messageText = \"Display Test\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 5;\r\n    typeOfMessage = 1;\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n\r\n  server.on(\"/power\", [=]() {\r\n    String const val = getPowerAuth();\r\n    server.send(200, \"text/plain\", val);\r\n  });\r\n  server.on(\"/master_power\", [=]() {\r\n    server.send(200, \"text/plain\", (requestedPowerState0 == 0) ? \"Warning\" : ((currentPowerState0 != -1) ? \"Enabled\" : \"Disabled\"));\r\n  });\r\n  server.on(\"/game_power\", [=]() {\r\n    server.send(200, \"text/plain\", (requestedPowerState0 >= 0) ? \"Warning\" : ((currentPowerState0 == 1) ? \"Enabled\" : \"Disabled\"));\r\n  });\r\n  server.on(\"/select_power\", [=]() {\r\n    server.send(200, \"text/plain\", (requestedPowerState0 >= 0) ? \"Warning\" : ((currentPowerState0 == 1) ? getGameSelect() : \"Disabled\"));\r\n  });\r\n\r\n  server.on(\"/timeout\", [=]() {\r\n    server.send(200, \"text/plain\", ((inactivityTimeout == true) ? \"ON\" : \"OFF\"));\r\n  });\r\n  server.on(\"/timeout/on\", [=]() {\r\n    if (inactivityTimeout == false) {\r\n      resetInactivityTimer();\r\n      inactivityTimeout = true;\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/timeout/off\", [=]() {\r\n     if (inactivityTimeout == true) {\r\n      inactivityTimeout = false;\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/timeout/set\", [=]() {\r\n    String response = \"UNCHANGED\";\r\n    if (server.hasArg(\"time\")) {\r\n      int _time = server.arg(\"time\").toInt();\r\n      defaultInactivityMinTimeout = _time;\r\n      resetInactivityTimer();\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n\r\n  server.on(\"/marquee/on\", [=]() {\r\n    if (currentMarqueeState == 0) {\r\n      setMarqueeState(true, true);\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/marquee/off\", [=]() {\r\n    if (currentMarqueeState == 1) {\r\n      setMarqueeState(false, true);\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/marquee\", [=]() {\r\n    server.send(200, \"text/plain\", ((currentMarqueeState == 0) ? (currentPowerState0 == 1) ? \"Enabled\" : \"Disabled\" : \"Enabled\"));\r\n  });\r\n\r\n  server.on(\"/setLED\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Data Sent\");\r\n    int bankSelect = 0;\r\n    if (server.hasArg(\"bankSelect\")) {\r\n      bankSelect = server.arg(\"bankSelect\").toInt();\r\n    }\r\n    if ((pending_release_leds == false && currentPowerState0 != 1) || server.hasArg(\"takeOwnership\")) {\r\n      if (bankSelect == 10) {\r\n        String req = \"LED_DATA::\";\r\n        if (server.hasArg(\"ledBrightness\")) {\r\n          req += server.arg(\"ledBrightness\");\r\n        } else {\r\n          req += \"64\";\r\n        }\r\n        req += \"::\";\r\n        if (server.hasArg(\"transition_time\")) {\r\n          req += server.hasArg(\"transition_time\");\r\n        } else {\r\n          req += \"0\";\r\n        }\r\n        req += \"::\";\r\n        req += ledValues;\r\n        req += \"::\";\r\n        \r\n        Serial.println(req);\r\n      } else {\r\n        int brightness = 64;\r\n        if (server.hasArg(\"ledBrightness\")) {\r\n          brightness = server.arg(\"ledBrightness\").toInt();\r\n          if (brightness > 0 && brightness <= 255) {\r\n            if (server.hasArg(\"transition_time\")) {\r\n              targetBrightness = brightness;\r\n            } else {\r\n              NeoPixelL.setBrightness(brightness);\r\n              NeoPixelR.setBrightness(brightness);\r\n            }\r\n          }\r\n        }\r\n        if (server.hasArg(\"takeOwnership\")) {\r\n          setLEDControl((server.arg(\"ledValues\").c_str() == \"true\"));\r\n        }\r\n        if (server.hasArg(\"transition_time\")) {\r\n          float _transition_time = server.arg(\"transition_time\").toFloat();\r\n          numSteps = _transition_time * 33.2;\r\n          transition_interval = (unsigned long)(1000.0 * _transition_time / (float)numSteps);\r\n        }\r\n\r\n        handleSetLeds(ledValues, bankSelect, (server.hasArg(\"transition_time\")));\r\n      }\r\n    }\r\n  });\r\n  server.on(\"/setLEDColor\", [=]() {\r\n    String ledValue = server.arg(\"ledColor\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Data Sent\");\r\n    if (pending_release_leds == false && (currentPowerState0 != 1 || currentGameSelected0 >= 10)) {\r\n      int brightness = 64;\r\n      int bankSelect = 0;\r\n      brightness = server.arg(\"ledBrightness\").toInt();\r\n      if (server.hasArg(\"takeOwnership\")) {\r\n        setLEDControl((server.arg(\"ledValues\").c_str() == \"true\"));\r\n      }\r\n      if (server.hasArg(\"transition_time\")) {\r\n        float _transition_time = server.arg(\"transition_time\").toFloat();\r\n        numSteps = _transition_time * 33.2;\r\n        transition_interval = (unsigned long)(1000.0 * _transition_time / (float)numSteps);\r\n      }\r\n      if (server.hasArg(\"ledBrightness\")) {\r\n        if (brightness > 0 && brightness <= 255) {\r\n          if (server.hasArg(\"transition_time\")) {\r\n            targetBrightness = brightness;\r\n          } else {\r\n            NeoPixelL.setBrightness(brightness);\r\n            NeoPixelR.setBrightness(brightness);\r\n          }\r\n        }\r\n      }\r\n      if (server.hasArg(\"bankSelect\")) {\r\n        bankSelect = server.arg(\"bankSelect\").toInt();\r\n      }\r\n\r\n      handleSetLedColor(ledValue, bankSelect, (server.hasArg(\"transition_time\")));\r\n    }\r\n  });\r\n  server.on(\"/state\", [=]() {\r\n    server.send(200, \"text/plain\", (currentLEDState == 0)  ? \"MCU\" : \"GAME\");\r\n  });\r\n  server.on(\"/state/return\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Returned to owner\");\r\n    resetState();\r\n  });\r\n  server.on(\"/state/reset\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Reset to standby\");\r\n    standbyLEDState();\r\n  });\r\n\r\n  server.begin();\r\n  delay(250);\r\n  //bootScreen(\"SYS_PWR_ON\");\r\n  //setMasterPowerOn();\r\n  //delay(500);\r\n  bootScreen(\"TASK_PCLINK\");\r\n  xTaskCreatePinnedToCore(\r\n                  serialLoop,   /* Task function. */\r\n                  \"serialMonitor\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task3,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_CARDCOM\");\r\n  xTaskCreatePinnedToCore(\r\n                  cardReaderRXLoop,   /* Task function. */\r\n                  \"cardReaderRX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task4,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  delay(101);\r\n  xTaskCreatePinnedToCore(\r\n                  cardReaderTXLoop,   /* Task function. */\r\n                  \"cardReaderTX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task5,      /* Task handle to keep track of created task */\r\n                  0);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_SOUND\");\r\n  xTaskCreatePinnedToCore(\r\n                    melodyPlayer,   /* Task function. */\r\n                    \"melodyTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    10,           /* priority of the task */\r\n                    &Task7,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_RA\");\r\n  xTaskCreatePinnedToCore(\r\n                    remoteAccessLoop,   /* Task function. */\r\n                    \"raTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    20,           /* priority of the task */\r\n                    &Task8,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_IR\");\r\n  xTaskCreatePinnedToCore(\r\n                    irRemoteLoop,   /* Task function. */\r\n                    \"irRemoteTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    20,           /* priority of the task */\r\n                    &Task9,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  displayedSec = esp_timer_get_time() / 1000000;\r\n  bootScreen(\"TASK_DISPLAY\");\r\n  xTaskCreatePinnedToCore(\r\n                    cpu0Loop,   /* Task function. */\r\n                    \"driverTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    10,           /* priority of the task */\r\n                    &Task1,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  melodyPlay = 2;\r\n  startMelody = true;\r\n}\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n  // Handle ALLS OK Card Reader Redirect\r\n  if (pending_alls_good_response == true && allsOK == true && coinEnable == false) {\r\n    cardReaderSerial.println(\"BLOCKER_OPEN::NO_DATA\");\r\n    delay(100);\r\n  }\r\n  // Handle LED Handover\r\n  if (pending_release_leds == true && coinEnable == true) {\r\n    pending_release_leds = false;\r\n    pending_alls_good_response = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n    kioskModeRequest(\"GameRunning\");\r\n    triggerLEDUpdate();\r\n    if (currentGameSelected0 > 19) {\r\n      pdaLEDState();\r\n    } else {\r\n      setLEDControl(false);\r\n    }\r\n  }\r\n  // else if (pending_release_leds == false && coinEnable == false && currentPowerState0 == 1 && !(currentALLSState0 == 1 && currentGameSelected0 == 10)) {\r\n  //  startingLEDState();\r\n  //}\r\n  // Handle Display Handover\r\n  displayMainState = (digitalRead(displayMainLDR) == LOW);\r\n  if (pending_release_display == true && coinEnable == true) {\r\n    pending_release_display = false;\r\n    if (currentGameSelected0 < 10) {\r\n      delay(6000);\r\n      setDisplayState(false);\r\n    }\r\n  }\r\n  // Drive LED Animations\r\n  if (transition_leds == true) {\r\n    if (currentStep == 0) {\r\n      sourceBrightness = NeoPixelL.getBrightness();\r\n      for (int i = 0; i < NUM_LEDS_1; i++) {\r\n        leds1_source[i] = leds1[i];\r\n      }\r\n      for (int i = 0; i < NUM_LEDS_2; i++) {\r\n        leds2_source[i] = leds2[i];\r\n      }\r\n    }\r\n    if (millis() - previousMillis >= transition_interval) {\r\n      // Save the last time we updated the LED colors\r\n      previousMillis = millis();\r\n      if (currentStep <= numSteps) {\r\n        NeoPixelL.setBrightness(map(currentStep, 0, numSteps, sourceBrightness, targetBrightness));\r\n        NeoPixelR.setBrightness(map(currentStep, 0, numSteps, sourceBrightness, targetBrightness));\r\n        for (int i = 0; i < NUM_LEDS_1; i++) {\r\n          leds1[i].r = map(currentStep, 0, numSteps, leds1_source[i].r, leds1_target[i].r);\r\n          leds1[i].g = map(currentStep, 0, numSteps, leds1_source[i].g, leds1_target[i].g);\r\n          leds1[i].b = map(currentStep, 0, numSteps, leds1_source[i].b, leds1_target[i].b);\r\n        }\r\n        for (int i = 0; i < NUM_LEDS_2; i++) {\r\n          leds2[i].r = map(currentStep, 0, numSteps, leds2_source[i].r, leds2_target[i].r);\r\n          leds2[i].g = map(currentStep, 0, numSteps, leds2_source[i].g, leds2_target[i].g);\r\n          leds2[i].b = map(currentStep, 0, numSteps, leds2_source[i].b, leds2_target[i].b);\r\n        }\r\n        copyLEDBuffer();\r\n        currentStep++;\r\n      } else if (animation_mode == 1) {\r\n        currentStep = 0;\r\n        if (animation_state == -1) {\r\n          for (int i = 0; i < NUM_LEDS_1; i++) {\r\n            leds1_target[i] = CRGB::Black;\r\n          }\r\n          for (int i = 0; i < NUM_LEDS_2; i++) {\r\n            leds2_target[i] = CRGB::Black;\r\n          }\r\n          numSteps = 3 * 33.2;\r\n          transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n          animation_state = 1;\r\n        } else {\r\n          for (int i = 0; i < NUM_LEDS_1; i++) {\r\n            leds1_target[i] = leds1_source[i];\r\n          }\r\n          for (int i = 0; i < NUM_LEDS_2; i++) {\r\n            leds2_target[i] = leds2_source[i];\r\n          }\r\n          numSteps = 3 * 33.2;\r\n          transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n          animation_state = -1;\r\n        }\r\n      } else {\r\n        transition_leds = false;\r\n        animation_state = -1;\r\n        animation_mode = -1;\r\n        currentStep = 0;\r\n        for (int i = 0; i < NUM_LEDS_1; i++) {\r\n          leds1_source[i] = leds1[i];\r\n        }\r\n        for (int i = 0; i < NUM_LEDS_2; i++) {\r\n          leds2_source[i] = leds2[i];\r\n        }\r\n        sourceBrightness = NeoPixelL.getBrightness();\r\n        copyLEDBuffer();\r\n        //if (pending_release_leds == true) {\r\n        //  setLEDControl(false);\r\n        //}\r\n        //pending_release_leds = false;\r\n      }\r\n    }\r\n  }\r\n  // Post Shutdown Cooldown\r\n  if (activeCooldownTimer >= 0) {\r\n    if (activeCooldownTimer == 0 && currentMillis - previousCooldownMillis >= (nuPostCooldownMinTimeout * 60000)) {\r\n      if (currentPowerState0 == 0) {\r\n        setChassisFanSpeed(50);\r\n      } else if (currentPowerState0 == -1) {\r\n        setChassisFanSpeed(30);\r\n      }\r\n      activeCooldownTimer = -1;\r\n    }\r\n    if (activeCooldownTimer == 1 && currentMillis - previousCooldownMillis >= (allsPostCooldownMinTimeout * 60000)) {\r\n      if (currentPowerState0 == 0) {\r\n        setChassisFanSpeed(50);\r\n      } else if (currentPowerState0 == -1) {\r\n        setChassisFanSpeed(30);\r\n      }\r\n      activeCooldownTimer = -1;\r\n    }\r\n  }\r\n  // Handle Inactivity Timer\r\n  if (inactivityTimeout == true && currentPowerState0 == 1 && requestedPowerState0 == -1 && ((currentMillis - previousInactivityMillis) >= (inactivityMinTimeout * 60000))) {\r\n    if (coinEnable == true || currentGameSelected0 > 19) {\r\n      shuttingDownLEDState(1);\r\n    } else if (coinEnable == false) {\r\n      setGameOff();\r\n    }\r\n  }\r\n  // Handle Shutdown Timer\r\n  if (currentPowerState0 == 1 && requestedPowerState0 > -1 && ((currentMillis - previousShutdownMillis) >= (shutdownDelayMinTimeout * 60000))) {\r\n    if (requestedPowerState0 == 0) {\r\n      setMasterPowerOff();\r\n    } else if (requestedPowerState0 == 1) {\r\n      setGameOff();\r\n    }\r\n    requestedPowerState0 = -1;\r\n  } else if (currentPowerState0 == 0 && requestedPowerState0 > -1) {\r\n    if (requestedPowerState0 == 0) {\r\n      setMasterPowerOff();\r\n    }\r\n    requestedPowerState0 = -1;\r\n  }\r\n}\r\n\r\nvoid cpu0Loop( void * pvParameters ) {\r\n  for(;;) {\r\n    runtime();\r\n  }\r\n}\r\nvoid remoteAccessLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    checkWiFiConnection();\r\n    server.handleClient();\r\n    delay(1);\r\n  }\r\n}\r\nbool enableIr = true;\r\nvoid irRemoteLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (enableIr && IrReceiver.decode()) {\r\n      uint16_t command = IrReceiver.decodedIRData.command;\r\n      uint16_t protocal = IrReceiver.decodedIRData.protocol;\r\n      if (protocal == 19) {\r\n        Serial.print(\"ACTION::IR_SIGNAL_\");\r\n        Serial.println(command);\r\n        int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        switch (command) {\r\n          case 7:\r\n            if (current_percent < 100 && muteVolume == false) {\r\n              current_percent += 5;\r\n              currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n              muteVolume = false;\r\n              ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n              displayVolumeMessage();\r\n            }\r\n            break;\r\n          case 11:\r\n            if (current_percent > 5 && muteVolume == false) {\r\n              current_percent -= 5;\r\n              currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n              muteVolume = false;\r\n              ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n              displayVolumeMessage();\r\n            }\r\n            break;\r\n          case 15:\r\n            muteVolume = !(muteVolume);\r\n            ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n            displayVolumeMessage();\r\n            break;\r\n          case 2:\r\n            if (currentPowerState0 == 1 && requestedPowerState0 == -1) {\r\n              requestStandby();\r\n            } else if (currentPowerState0 == 1 && requestedPowerState0 > -1) {\r\n              setGameOff();\r\n            } else if (currentPowerState0 == 0) {\r\n              setGameOn();\r\n            } else if (currentPowerState0 == -1) {\r\n              setMasterPowerOn();\r\n            }\r\n            delay(1000);\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n      delay(150);\r\n      IrReceiver.resume();\r\n    } else {\r\n      delay(1);\r\n    }\r\n  }\r\n}\r\nvoid melodyPlayer( void * pvParameters ) {\r\n  for(;;) {\r\n    // Play Melody Sheets\r\n    if (startMelody == true) {\r\n      if (millis() - previousMelodyMillis >= pauseBetweenNotes) {\r\n        previousMelodyMillis = millis();\r\n        if (melodyPlay == 0) {\r\n          playMelody(booting_tone, booting_tone_dur, sizeof(booting_tone_dur) / sizeof(int));\r\n        } else if (melodyPlay == 1) {\r\n          playMelody(shutting_down_tone, shutting_down_dur, sizeof(shutting_down_dur) / sizeof(int));\r\n        } else if (melodyPlay == 2) {\r\n          playMelody(boot_tone, boot_tone_dur, sizeof(boot_tone_dur) / sizeof(int));\r\n        } else if (melodyPlay == 3) {\r\n          const float position = ((millis() - previousShutdownMillis) / 60000);\r\n          int val = map(position, 0, 4, loopMelody, 0) * 1000;\r\n          if (val <= 1) {\r\n            playMelody(warning_tone_long, warning_tone_long_dur, sizeof(warning_tone_long_dur) / sizeof(int));\r\n          } else {\r\n            playMelody(warning_tone, warning_tone_dur, sizeof(warning_tone_dur) / sizeof(int));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}\r\nvoid pingLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    delay(1000);\r\n    Serial.println(\"\");\r\n    Serial.println(\"PROBE::SEARCH\");\r\n    Serial.println(\"\");\r\n  }\r\n}\r\nvoid serialLoop( void * pvParameters ) {\r\n  kioskCommand();\r\n}\r\nvoid cardReaderTXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (typeOfMessage != -1) {\r\n      // DISPLAY_MESSAGE::BIG::icon::text::isJP/t::255::invert/t::timeout/20\r\n      cardReaderSerial.print(\"DISPLAY_MESSAGE::\");\r\n      cardReaderSerial.print((typeOfMessage == 1) ? \"BIG\" : \"SMALL\");\r\n      typeOfMessage = -1;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(String(messageIcon));\r\n      messageIcon = 0;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(messageText);\r\n      messageText = \"\";\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print((isJpnMessage == true) ? \"t\" : \"f\");\r\n      isJpnMessage = false;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(String(brightMessage));\r\n      brightMessage = 1;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print((invertMessage == true) ? \"t\" : \"f\");\r\n      invertMessage = false;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.println(String(timeoutMessage));\r\n      timeoutMessage = 0;\r\n    }\r\n    int value = 0;\r\n    if (currentPowerState0 == -1 || (currentPowerState0 == 1 && requestedPowerState0 != -1)) {\r\n      value = 0;\r\n    } else if (currentPowerState0 == 0) {\r\n      value = 1;\r\n    } else if (currentPowerState0 == 1 && requestedPowerState0 == -1) {\r\n      value = 2;\r\n    }\r\n    cardReaderSerial.println(\"POWER_SWITCH::\" + String(value));\r\n    delay(100);\r\n  }\r\n}\r\nvoid cardReaderRXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (cardReaderSerial.available()) {\r\n      static String receivedMessage = \"\";\r\n      char c;\r\n      bool messageStarted = false;\r\n\r\n      while (cardReaderSerial.available()) {\r\n        c = cardReaderSerial.read();\r\n        if (c == '\\n') {\r\n          if (!receivedMessage.isEmpty()) {\r\n            handleCRMessage(receivedMessage);\r\n            //Serial.println(\"Received: \" + receivedMessage);\r\n          }\r\n          receivedMessage = \"\";\r\n        } else {\r\n          receivedMessage += c;\r\n        }\r\n\r\n      }\r\n    } else {\r\n      delay(1);\r\n    }\r\n  }\r\n}\r\nvoid nuControlRXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (nuControl.available()) {\r\n      static String receivedMessage = \"\";\r\n      char c;\r\n      bool messageStarted = false;\r\n\r\n      while (nuControl.available()) {\r\n        c = nuControl.read();\r\n        if (c == '\\n') {\r\n          if (!receivedMessage.isEmpty()) {\r\n            int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n            if (delimiterIndex != -1) {\r\n              int headerIndex = receivedMessage.indexOf(\"::\");\r\n              String header = receivedMessage.substring(0, headerIndex);\r\n              if (header == \"PS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 2) {\r\n                  currentNuPowerState0 = valueInt;\r\n                }\r\n              } else if (header == \"DS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 9 && inhibitNuState == false) {\r\n                  currentGameSelected0 = valueInt;\r\n                }\r\n              } else if (header == \"R\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String _nuResponse = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                _nuResponse.trim();\r\n                nuResponse = _nuResponse;\r\n                Serial.println(\"NU_CTRL::\" + nuResponse);\r\n              }\r\n            }\r\n          }\r\n          receivedMessage = \"\";\r\n        } else {\r\n          receivedMessage += c;\r\n        }\r\n\r\n      }\r\n    } else {\r\n      delay(1);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nvoid runtime() {\r\n  int time_in_sec = esp_timer_get_time() / 1000000;\r\n  int current_time = (time_in_sec - displayedSec) / 2;\r\n\r\n  if (displayState != 1 && currentPowerState0 == -1) {\r\n      const String power = getPowerAuth();\r\n      displayIconDualMessage(1, false, false, (power == \"Active\") ? 491 : 490, \"System Power\", power);\r\n      displayState = 1;\r\n  } else if (currentPowerState0 == -1) {\r\n    delay(500);\r\n  } else if (currentPowerState0 != -1) {\r\n    if (displayState != 0 && current_time < 1) {\r\n      displayIconMessage(1, true, true, 250, \"チュウニズム\");\r\n      displayState = 0;\r\n    } else if (displayState != 1 && current_time >= 1 && current_time < 2) {\r\n      const String power = getPowerAuth();\r\n      displayIconDualMessage(1, (power == \"Active\"), false, (power == \"Active\") ? 491 : 490, \"System Power\", power);\r\n      displayState = 1;\r\n    } else if (displayState != 2 && current_time >= 2 && current_time < 3) {\r\n      String timeout = \"\";\r\n      if (requestedPowerState0 != -1) {\r\n        timeout = \"Expired\";\r\n      } else if (currentPowerState0 == 1 && inactivityTimeout == true) {\r\n        timeout = String(inactivityMinTimeout - ((millis() - previousInactivityMillis) / 60000));\r\n        timeout += \" Min\";\r\n      } else {\r\n        timeout = \"Disabled\";\r\n      }\r\n      displayIconDualMessage(1, ((currentPowerState0 == 1 && inactivityTimeout == true && (((millis() - previousInactivityMillis) / 60000) < (inactivityMinTimeout - 5))) ? true : false), false, 459, \"Timeout\", timeout);\r\n      displayState = 2;\r\n    } else if (displayState != 3 && current_time >= 3 && current_time < 4) {\r\n      String volume = \"\";\r\n      if (muteVolume == false) {\r\n        volume += map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        volume += \"%\";\r\n      } else {\r\n        volume = \"Muted\";\r\n      }\r\n      displayIconDualMessage(1, (currentVolume >= 50 || muteVolume == true), false, 578, \"Speakers\", volume.c_str());\r\n      displayState = 3;\r\n    } else if (displayState != 4 && current_time >= 4 && current_time < 5) {\r\n      String fan = \"\";\r\n      fan += map(currentFanSpeed, 0, 255, 0, 100);\r\n      fan += \"%\";\r\n      displayIconDualMessage(1, (map(currentFanSpeed, 0, 255, 0, 100) >= 75), false, 225, \"Fans\", fan.c_str());\r\n      displayState = 4;\r\n    } else if (displayState != 5 && current_time >= 5 && current_time < 6) {\r\n      displayIconDualMessage(1, (currentMarqueeState == 1), false, 398, \"Marquee\", (currentMarqueeState == 1) ? \"Enabled\" : \"Disabled\");\r\n      displayState = 5;\r\n    } else if (displayState != 6 && current_time >= 6 && current_time < 7) {\r\n      displayIconDualMessage(1, (displayMainState == false), false, (displayMainState == false) ? 250 : 129, \"Display Source\", (displayMainState == true) ? \"PC\" : \"Game\");\r\n      displayState = 6;\r\n    } else if (displayState != 7 && current_time >= 7 && current_time < 8) {\r\n      displayIconDualMessage(1, (currentLEDState == 1), false, 398, \"LED Control\", (currentLEDState == 0) ? \"MCU\" : \"Game\");\r\n      displayState = 7;\r\n    } else if (displayState != 8 && current_time >= 8 && current_time < 9) {\r\n      displayIconDualMessage(1, false, false, 141, \"Game Disk\", getGameSelect());\r\n      displayState = 8;\r\n    } else if (displayState != 9 && current_time >= 9 && current_time < 10) {\r\n      displayIconDualMessage(1, false, false, 510, \"VPN: Chunithm\", getEthSwitchVal(0));\r\n      displayState = 9;\r\n    } else if (displayState != 10 && current_time >= 10 && current_time < 11) {\r\n      displayIconDualMessage(1, false, false, 510, \"VPN: WACCA\", getEthSwitchVal(1));\r\n      displayState = 10;\r\n    } else if (displayState != 11 && current_time >= 11 && current_time < 12) {\r\n      displayIconDualMessage(1, (coinEnable == true), false, 71, \"Card Reader\", (has_cr_talked == false) ? \"No Data\" : (coinEnable == true) ? (currentGameSelected0 == 20) ? \"Enabled*\" : \"Enabled\" : \"Disabled\");\r\n      displayState = 11;\r\n    } else if (current_time >= 12) {\r\n      displayedSec = time_in_sec;\r\n    }\r\n  }\r\n}\r\nvoid bootScreen(String input_message) {\r\n  u8g2.clearBuffer();\r\n  u8g2.setFont(u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  const char* string = input_message.c_str();\r\n  int textWidth = u8g2.getStrWidth(string);\r\n  int centerX = ((u8g2.getWidth() - textWidth) / 2);\r\n  int centerGlX = ((u8g2.getWidth() - textWidth) / 2);\r\n  int centerY = u8g2.getHeight() / 2 + u8g2.getAscent() / 2;\r\n  u8g2.drawStr(centerX, centerY, string);\r\n  u8g2.sendBuffer();\r\n}\r\nvoid playMelody(int tones[], int durations[], int size) {\r\n  if (currentNote < size) {\r\n    int noteDuration = 1000 / durations[currentNote];\r\n    tone(buzzer_pin, tones[currentNote], noteDuration);\r\n    pauseBetweenNotes = noteDuration * 1.30;\r\n    currentNote++;\r\n  } else {\r\n    // Melody is finished\r\n    currentNote = 0;\r\n    if (loopMelody != -1) {\r\n      if (melodyPlay == 3) {\r\n        const float position = ((millis() - previousShutdownMillis) / 60000);\r\n        pauseBetweenNotes = map(position, 0, 4, loopMelody, 0) * 1000;\r\n      } else {\r\n        pauseBetweenNotes = loopMelody * 1000;\r\n      }\r\n    } else {\r\n      startMelody = false;\r\n      currentNote = 0;\r\n      previousMelodyMillis = 0;\r\n      melodyPlay = -1;\r\n    }\r\n  }\r\n}\r\nvoid displayIconMessage(int bright, bool invert, bool jpn, int icon, String input_message) {\r\n  u8g2.setPowerSave(0);\r\n  u8g2.setContrast(bright);\r\n  u8g2.clearBuffer();\r\n  int Xpos = 2;\r\n  const char* string = input_message.c_str();\r\n  if (invert == true) {\r\n    u8g2.setDrawColor(1);\r\n    u8g2.drawBox(0, 0, u8g2.getWidth(), u8g2.getHeight());\r\n    u8g2.sendBuffer();\r\n    u8g2.setDrawColor(0);\r\n    u8g2.setColorIndex(0);\r\n  }\r\n  u8g2.setFont((jpn == true) ? u8g2_font_b12_t_japanese1 : u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  int textWidth = u8g2.getUTF8Width(string);\r\n  int centerX = Xpos + 28;\r\n  int centerY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawUTF8(centerX, centerY, string);\r\n  u8g2.setFont(u8g2_font_streamline_all_t);\r\n  int centerGlX = Xpos;\r\n  int centerGlY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawGlyph(centerGlX, centerGlY, icon);\r\n  u8g2.setDrawColor(1);\r\n  u8g2.sendBuffer();\r\n}\r\nvoid displayIconDualMessage(int bright, bool invert, bool jpn, int icon, String input_message, String input2_message) {\r\n  u8g2.setPowerSave(0);\r\n  u8g2.setContrast(bright);\r\n  u8g2.clearBuffer();\r\n  int Xpos = 2;\r\n  const char* string = input_message.c_str();\r\n  const char* string2 = input2_message.c_str();\r\n  if (invert == true) {\r\n    u8g2.setDrawColor(1);\r\n    u8g2.drawBox(0, 0, u8g2.getWidth(), u8g2.getHeight());\r\n    u8g2.sendBuffer();\r\n    u8g2.setDrawColor(0);\r\n    u8g2.setColorIndex(0);\r\n  }\r\n  u8g2.setFont((jpn == true) ? u8g2_font_b12_t_japanese1 : u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  int textWidth = u8g2.getUTF8Width(string);\r\n  int centerX = Xpos + 28;\r\n  int centerY = ((u8g2.getHeight() / 2 + u8g2.getAscent() / 2) / 2) + 2;\r\n  int centerY2 = (centerY * 2) + 3;\r\n  u8g2.drawUTF8(centerX, centerY, string);\r\n  u8g2.drawUTF8(centerX, centerY2, string2);\r\n  u8g2.setFont(u8g2_font_streamline_all_t);\r\n  int centerGlX = Xpos;\r\n  int centerGlY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawGlyph(centerGlX, centerGlY, icon);\r\n  u8g2.setDrawColor(1);\r\n  u8g2.sendBuffer();\r\n}\r\n\r\nString getEthSwitchVal(int cabNum) {\r\n  return ((digitalRead(ethSensors[cabNum])) == LOW) ? \"Official\" : \"Private\";\r\n}\r\nString getGameSelect() {\r\n  String assembledOutput = \"\";\r\n  switch (currentGameSelected0) {\r\n    case -1:\r\n      assembledOutput = \"No Data\";\r\n      break;\r\n    case 0:\r\n      assembledOutput = \"PL Omni\";\r\n      break;\r\n    case 1:\r\n      assembledOutput = \"PL Base\";\r\n      break;\r\n    case 2:\r\n      assembledOutput = \"Air\";\r\n      break;\r\n    case 3:\r\n      assembledOutput = \"Star\";\r\n      break;\r\n    case 4:\r\n      assembledOutput = \"Crystal\";\r\n      break;\r\n    case 5:\r\n      assembledOutput = \"Other\";\r\n      break;\r\n    case 10:\r\n      assembledOutput = \"Sun+\";\r\n      break;\r\n    case 11:\r\n      assembledOutput = \"New+\";\r\n      break;\r\n    case 20:\r\n      assembledOutput = \"PDA:FT\";\r\n      break;\r\n    default:\r\n      assembledOutput = \"Invalid\";\r\n      break;\r\n  }\r\n  return assembledOutput;\r\n}\r\nString getPowerAuth() {\r\n  String assembledOutput = \"\";\r\n  assembledOutput += ((requestedPowerState0 != -1) ? \"Warning\" : ((currentPowerState0 == -1) ? \"Power Off\" : (currentPowerState0 == 0) ? \"Standby\" : (coinEnable == false) ? \"Startup\" : \"Active\"));\r\n  return assembledOutput;\r\n}\r\nvoid displayVolumeMessage() {\r\n  int curVol = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n  if (muteVolume == true) {\r\n    messageIcon = 279;\r\n    messageText = \"Volume Muted\";\r\n    invertMessage = true;\r\n  } else {\r\n    messageIcon = 277;\r\n    messageText = \"Volume: \";\r\n    messageText += String(curVol);\r\n    messageText += \"%\";\r\n    invertMessage = (curVol >= 40);\r\n  }\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  timeoutMessage = 10;\r\n  typeOfMessage = 1;\r\n}\r\n\r\nvoid defaultLEDState() {\r\n  NeoPixelL.setBrightness(0);\r\n  NeoPixelR.setBrightness(0);\r\n  for (int i = 0; i < NUM_LEDS_1; i++) {\r\n    leds1[i] = CRGB::Black;\r\n  }\r\n  for (int i = 0; i < NUM_LEDS_2; i++) {\r\n    leds2[i] = CRGB::Black;\r\n  }\r\n  copyLEDBuffer();\r\n}\r\nvoid standbyLEDState() {\r\n  NeoPixelL.setBrightness(32);\r\n  NeoPixelR.setBrightness(32);\r\n  setUpperLEDColor(CRGB::Black, false);\r\n  setSideLEDs(CRGB::Yellow, CRGB::Yellow, false);\r\n  copyLEDBuffer();\r\n}\r\nvoid pdaLEDState() {\r\n  NeoPixelL.setBrightness(32);\r\n  NeoPixelR.setBrightness(32);\r\n  setUpperLEDColor(CRGB::Black, false);\r\n  setSideLEDs(CRGB::Cyan, CRGB::Cyan, false);\r\n  copyLEDBuffer();\r\n}\r\nvoid startingLEDState() {\r\n  setLEDControl(true);\r\n  targetBrightness = 128;\r\n  numSteps = 4.0 * 33.2;\r\n  transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n  setUpperLEDColor(CRGB::Black, true);\r\n  setSideLEDs(CRGB::Green, CRGB::Green, true);\r\n  pending_release_leds = true;\r\n  animation_state = -1;\r\n  animation_mode = 1;\r\n  currentStep = 0;\r\n  transition_leds = true;\r\n  triggerLEDUpdate();\r\n}\r\nvoid shuttingDownLEDState(int state) {\r\n  previousShutdownMillis = millis();\r\n\r\n  currentNote = 0;\r\n  previousMelodyMillis = 0;\r\n  melodyPlay = 3;\r\n  loopMelody = 2;\r\n  startMelody = true;\r\n\r\n  kioskModeRequest(\"WarningGame\");\r\n  setLEDControl(true);\r\n  targetBrightness = 255;\r\n  numSteps = 4.0 * 33.2;\r\n  transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n  setUpperLEDColor(CRGB::Black, true);\r\n  setSideLEDs(CRGB::Red, CRGB::Red, true);\r\n  pending_release_leds = false;\r\n  animation_state = -1;\r\n  animation_mode = 1;\r\n  currentStep = 0;\r\n  transition_leds = true;\r\n\r\n  messageIcon = (requestedPowerState0 == -1) ? 96 : 223;\r\n  messageText = (requestedPowerState0 == -1) ? \"Power Off\" : \"Standby\";\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  invertMessage = true;\r\n  timeoutMessage = 25;\r\n  typeOfMessage = 1;\r\n\r\n  requestedPowerState0 = state;\r\n}\r\nvoid startLoadingScreen() {\r\n  pending_release_display = true;\r\n  if (currentGameSelected0 < 20) {\r\n    kioskModeRequest((currentGameSelected0 >= 10) ? \"StartALLSGame\" : \"StartGame\");\r\n  }\r\n}\r\n\r\nvoid setUpperLED(String ledValues, bool should_transition) {\r\n  int index = 0;\r\n  while (ledValues.length() > 0 && index < (NUM_LEDS_1 + NUM_LEDS_2)) {\r\n    String hexValue = ledValues.substring(0, ledValues.indexOf(' '));\r\n    ledValues = ledValues.substring(ledValues.indexOf(' ') + 1);\r\n    uint32_t color = (uint32_t)strtol(hexValue.c_str(), NULL, 16);\r\n    if (index > (NUM_LEDS_1 - 1)) {\r\n      leds1[index] = color;\r\n    } else {\r\n      leds2[(index - NUM_LEDS_1)] = color;\r\n    }\r\n    index++;\r\n  }\r\n}\r\nvoid setUpperLEDColor(uint32_t color, bool should_transition) {\r\n  for (int i = 0; i < 50; i++) {\r\n    if (should_transition == true) {\r\n      leds1_target[i] = color;\r\n    } else {\r\n      leds1[i] = color;\r\n    }\r\n  }\r\n  for (int i = 0; i < 60; i++) {\r\n    if (should_transition == true) {\r\n      leds2_target[i] = color;\r\n    } else {\r\n      leds2[i] = color;\r\n    }\r\n  }\r\n}\r\nvoid setSideLEDs(uint32_t colorL, uint32_t colorR, bool should_transition) {\r\n  for (int i = 0; i < 3; i++) {\r\n    if (should_transition == true) {\r\n      leds1_target[50 + i] = colorL;\r\n    } else {\r\n      leds1[50 + i] = colorL;\r\n    }\r\n  }\r\n  for (int i = 0; i < 3; i++) {\r\n    if (should_transition == true) {\r\n      leds2_target[60 + i] = colorR;\r\n    } else {\r\n      leds2[60 + i] = colorR;\r\n    }\r\n  }\r\n}\r\nvoid copyLEDBuffer() {\r\n  for (int i = 0; i < NUM_LEDS_1; i++) {\r\n    NeoPixelL.setPixelColor(i, NeoPixelL.Color(leds1[i].r, leds1[i].g, leds1[i].b));\r\n  }\r\n  for (int i = 0; i < NUM_LEDS_2; i++) {\r\n    NeoPixelR.setPixelColor(i, NeoPixelR.Color(leds2[i].r, leds2[i].g, leds2[i].b));\r\n  }\r\n  enableIr = false;\r\n  delay(1);\r\n  if (IrReceiver.isIdle()) {\r\n    NeoPixelL.show();\r\n  }\r\n  if (IrReceiver.isIdle()) {\r\n    NeoPixelR.show();\r\n  }\r\n  enableIr = true;\r\n}\r\n\r\nvoid handleSetLeds(String ledValues, int bankSelect, bool should_transition) {\r\n  int index = 0;\r\n  int ledIndex = 0;\r\n  while (ledValues.length() > 0 && index < (NUM_LEDS_1 + NUM_LEDS_2)) {\r\n    String hexValue = ledValues.substring(0, ledValues.indexOf(' '));\r\n    ledValues = ledValues.substring(ledValues.indexOf(' ') + 1);\r\n    uint32_t color = (uint32_t)strtol(hexValue.c_str(), NULL, 16);\r\n\r\n\r\n    if (index < (NUM_LEDS_1 + NUM_LEDS_2)) {\r\n      if (bankSelect == 0) {\r\n        if (index == ledIndex) {\r\n          if (should_transition == true) {\r\n            leds1_target[ledIndex] = color;\r\n          } else {\r\n            leds1[ledIndex] = color;\r\n          }\r\n          ledIndex++;\r\n          if (ledIndex >= NUM_LEDS_1) {\r\n            ledIndex = 0;\r\n          }\r\n        } else if (should_transition == true) {\r\n          leds2_target[ledIndex] = color;\r\n          ledIndex++;\r\n        } else {\r\n          leds2[ledIndex] = color;\r\n          ledIndex++;\r\n        }\r\n      }\r\n    }\r\n    index++;\r\n  }\r\n  if (should_transition == true) {\r\n    for (int i = 0; i < NUM_LEDS_1; i++) {\r\n      leds1_source[i] = leds1[i];\r\n    }\r\n    for (int i = 0; i < NUM_LEDS_2; i++) {\r\n      leds2_source[i] = leds2[i];\r\n    }\r\n    bool all_same = true;\r\n    for (int i = 0; i < NUM_LEDS_1; i++) {\r\n      if (leds1_source[i].r != leds1_target[i].r && leds1_source[i].g != leds1_target[i].g && leds1_source[i].b != leds1_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (sourceBrightness != targetBrightness) {\r\n      all_same = false;\r\n    }\r\n    for (int i = 0; i < NUM_LEDS_2; i++) {\r\n      if (leds2_source[i].r != leds2_target[i].r && leds2_source[i].g != leds2_target[i].g && leds2_source[i].b != leds2_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (all_same == false) {\r\n      transition_leds = true;\r\n    } else {\r\n      copyLEDBuffer();\r\n    }\r\n  } else {\r\n    copyLEDBuffer();\r\n  }\r\n}\r\nvoid handleSetLedColor(String ledValue, int bankSelect, bool should_transition) {\r\n  uint32_t color = (uint32_t)strtol(ledValue.c_str(), NULL, 16);\r\n  int index = 0;\r\n  if (bankSelect == 0) {\r\n    if (should_transition == true) {\r\n      for (int i = 0; i < NUM_LEDS_1; i++) {\r\n        leds1_target[i] = color;\r\n      }\r\n      for (int i = 0; i < NUM_LEDS_2; i++) {\r\n        leds2_target[i] = color;\r\n      }\r\n    } else {\r\n      for (int i = 0; i < NUM_LEDS_1; i++) {\r\n        leds1[i] = color;\r\n      }\r\n      for (int i = 0; i < NUM_LEDS_2; i++) {\r\n        leds2[i] = color;\r\n      }\r\n    }\r\n  } else if (bankSelect == 1) {\r\n    setUpperLEDColor(color, should_transition);\r\n  } else if (bankSelect == 2) {\r\n    setSideLEDs(color, color, should_transition);\r\n  }\r\n  if (should_transition == true) {\r\n    for (int i = 0; i < NUM_LEDS_1; i++) {\r\n      leds1_source[i] = leds1[i];\r\n    }\r\n    for (int i = 0; i < NUM_LEDS_2; i++) {\r\n      leds2_source[i] = leds2[i];\r\n    }\r\n    bool all_same = true;\r\n    for (int i = 0; i < NUM_LEDS_1; i++) {\r\n      if (leds1_source[i].r != leds1_target[i].r && leds1_source[i].g != leds1_target[i].g && leds1_source[i].b != leds1_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (sourceBrightness != targetBrightness) {\r\n      all_same = false;\r\n    }\r\n    for (int i = 0; i < NUM_LEDS_2; i++) {\r\n      if (leds2_source[i].r != leds2_target[i].r && leds2_source[i].g != leds2_target[i].g && leds2_source[i].b != leds2_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (all_same == false) {\r\n      transition_leds = true;\r\n    } else {\r\n      copyLEDBuffer();\r\n    }\r\n  } else {\r\n    copyLEDBuffer();\r\n  }\r\n}\r\nbool ignore_next_state = false;\r\nvoid handleCRMessage(String inputString) {\r\n  int delimiterIndex = inputString.indexOf(\"::\");\r\n  if (delimiterIndex != -1) {\r\n    int headerIndex = inputString.indexOf(\"::\");\r\n    String header = inputString.substring(0, headerIndex);\r\n    if (header == \"COIN_ENABLE\") {\r\n      has_cr_talked = true;\r\n      ignore_next_state = false;\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      int responseCode = valueString.toInt();\r\n      switch (responseCode) {\r\n        case 0:\r\n          coinEnable = false;\r\n          break;\r\n        case 1:\r\n          coinEnable = true;\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else if (header == \"COIN_DISPENSE\") {\r\n      has_cr_talked = true;\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      int responseCode = valueString.toInt();\r\n      int dataIndex = inputString.indexOf(\"::\", valueIndex + 2);\r\n      String dataString = inputString.substring(valueIndex + 2, dataIndex);\r\n\r\n      Serial.print(\"COIN_DISPENSE::\");\r\n      Serial.print(valueString);\r\n      Serial.print(\"::\");\r\n      Serial.println(dataString);\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        if (responseCode >= 200 && responseCode < 300) {\r\n          resetInactivityTimer();\r\n        }\r\n      }\r\n    } else if (header == \"BUTTON_REQUEST\") {\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        kioskModeRequest(\"BUTTON_\" + valueString);\r\n      }\r\n    } else if (header == \"GPIO\") {\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        Serial.println(\"\");\r\n        Serial.println(\"GPIO::\" + valueString);\r\n        Serial.println(\"\");\r\n      }\r\n    } else if (header == \"BOOT_REQUEST\") {\r\n      has_cr_talked = true;\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        setGameOn();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid setMasterPowerOn() {\r\n  if (currentPowerState0 == -1) {\r\n    setIOPower(true);\r\n    delay(250);\r\n    setLEDControl(true);\r\n    kioskModeRequest(\"StartStandby\");\r\n    resetMarqueeState();\r\n    if (activeCooldownTimer == -1) {\r\n      setChassisFanSpeed(50);\r\n    } else {\r\n      setChassisFanSpeed((currentGameSelected0 < 10) ? 75 : 100);\r\n    }\r\n    delay(500);\r\n    defaultLEDState();\r\n    standbyLEDState();\r\n    setDisplayState(true);\r\n    currentPowerState0 = 0;\r\n\r\n    pending_release_leds = false;\r\n    pending_release_display = false;\r\n    pending_alls_good_response = false;\r\n    allsOK = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n\r\n    messageIcon = 223;\r\n    messageText = \"Standby Mode\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n    triggerLEDUpdate();\r\n  }\r\n  requestedPowerState0 = -1;\r\n}\r\nvoid setMasterPowerOff() {\r\n  kioskModeRequest(\"StopAll\");\r\n  if (activeCooldownTimer == -1) {\r\n    setChassisFanSpeed(30);\r\n  } else {\r\n      setChassisFanSpeed((currentGameSelected0 < 10) ? 75 : 100);\r\n  }\r\n  setLEDControl(true);\r\n  setMarqueeState(false, false);\r\n  if (currentPowerState0 == 1) {\r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n    delay(500);\r\n    setSysBoardPower(false);\r\n    setTouchControl(false);\r\n    delay(200);\r\n  } else {\r\n    melodyPlay = -1;\r\n    loopMelody = -1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = false;\r\n  }\r\n  delay(500);\r\n  setIOPower(false);\r\n  setDisplayState(true);\r\n  if (currentPowerState0 != -1) {\r\n    messageIcon = 96;\r\n    messageText = \"Power Off\";\r\n    isJpnMessage = false;\r\n    brightMessage = 1;\r\n    invertMessage = true;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  requestedPowerState0 = -1;\r\n  currentPowerState0 = -1;\r\n  triggerLEDUpdate();\r\n}\r\nvoid setGameOn() {\r\n  if (currentPowerState0 == -1) {\r\n    setIOPower(true);\r\n    delay(1000);\r\n  }\r\n  if (currentPowerState0 != 1) {\r\n    melodyPlay = 0;\r\n    loopMelody = -1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n\r\n    inactivityMinTimeout = defaultInactivityMinTimeout + 5;\r\n    previousInactivityMillis = millis();\r\n    setTouchControl((currentGameSelected0 < 10));\r\n    setDisplayState(true);\r\n    setSysBoardPower(true);\r\n    resetPSU();\r\n    if (currentGameSelected0 < 20) {\r\n      startLoadingScreen();\r\n    } else {\r\n      pending_alls_good_response = true;\r\n    }\r\n    startingLEDState();\r\n    setMarqueeState(true, false);\r\n    setChassisFanSpeed((currentGameSelected0 < 10) ? 75 : 100);\r\n\r\n    pending_release_display = (currentGameSelected0 < 10);\r\n\r\n    messageIcon = 96;\r\n    messageText = \"Game On\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = true;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  if (requestedPowerState0 != -1) {\r\n    resetState();\r\n  }\r\n  requestedPowerState0 = -1;\r\n  currentPowerState0 = 1;\r\n  triggerLEDUpdate();\r\n}\r\nvoid setGameOff() {\r\n  if (currentPowerState0 == 1) {\r\n    currentPowerState0 = 0;\r\n\r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n\r\n    pending_release_leds = false;\r\n    pending_release_display = false;\r\n    pending_alls_good_response = false;\r\n    allsOK = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n\r\n    for (int i = 0; i < 3; i++) {\r\n      cardReaderSerial.println(\"BLOCKER_CLOSE::NO_DATA\");\r\n      delay(100);\r\n    }\r\n    setDisplayState(true);\r\n    setSysBoardPower(false);\r\n    setTouchControl(false);\r\n    setLEDControl(true);\r\n    resetPSU();\r\n    activeCooldownTimer = 0;\r\n    previousCooldownMillis = millis();\r\n    kioskModeRequest(\"StartStandby\");\r\n    delay(250);\r\n    standbyLEDState();\r\n    resetMarqueeState();\r\n    setChassisFanSpeed((currentGameSelected0 < 10) ? 75 : 100);\r\n\r\n    messageIcon = 223;\r\n    messageText = \"Standby Mode\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  currentPowerState0 = 0;\r\n  requestedPowerState0 = -1;\r\n  triggerLEDUpdate();\r\n}\r\nvoid requestPowerOff() {\r\n  if (currentPowerState0 == 1 && (coinEnable == true || currentGameSelected0 == 20)) {\r\n    shuttingDownLEDState(0);\r\n  } else if (currentPowerState0 == 1 && coinEnable == false) {\r\n    setMasterPowerOff();\r\n  } else if (currentPowerState0 == 0) {\r\n    setMasterPowerOff();\r\n  }\r\n}\r\nvoid requestStandby() {\r\n  if (currentPowerState0 == 1 && (coinEnable == true || currentGameSelected0 > 19)) {\r\n    shuttingDownLEDState(1);\r\n  } else if (currentPowerState0 == 1 && coinEnable == false) {\r\n    setGameOff();\r\n  } else {\r\n    setMasterPowerOn();\r\n  }\r\n}\r\n\r\nvoid setSysBoardPower(bool state) {\r\n  nuResponse = \"\";\r\n  while (currentNuPowerState0 == ((currentGameSelected0 < 10) ? ((state == true) ? 0 : 1) : 1)) {\r\n    nuControl.print(\"PS::\");\r\n    nuControl.println(((currentGameSelected0 < 10) ? ((state == true) ? \"1\" : \"0\") : \"0\"));\r\n    delay(100);\r\n  }\r\n  digitalWrite(controlRelays[1], ((currentGameSelected0 < 10) ? ((state == true) ? HIGH : LOW) : LOW));\r\n  ALLSCtrl(\"PS\", ((currentGameSelected0 >= 10) ? ((state == true) ? \"1\" : \"0\") : \"0\"));\r\n  delay((state == true) ? 200 : 500);\r\n}\r\nvoid setLEDControl(bool state) {\r\n  digitalWrite(controlRelays[3], (state == true) ? LOW : HIGH);\r\n  currentLEDState = (state == true) ? 0 : 1;\r\n}\r\nvoid setTouchControl(bool state) {\r\n  digitalWrite(controlRelays[4], (state == true) ? HIGH : LOW);\r\n  currentSliderState = (state == true) ? 0 : 1;\r\n}\r\nvoid setIOPower(bool state) {\r\n  digitalWrite(controlRelays[0], (state == true) ? HIGH : LOW);\r\n}\r\nvoid resetPSU() {\r\n  Serial.println(\"LED_DATA::16::0::000000::\");\r\n  digitalWrite(controlRelays[0], LOW);\r\n  delay(2300);\r\n  digitalWrite(controlRelays[0], HIGH);\r\n}\r\nvoid resetMarqueeState() {\r\n  digitalWrite(controlRelays[2], (currentMarqueeState == 1) ? HIGH : LOW);\r\n}\r\nvoid setMarqueeState(bool state, bool save) {\r\n  if (currentPowerState0 != -1) {\r\n    digitalWrite(controlRelays[2], (state == true) ? HIGH : LOW);\r\n  }\r\n  if (save == true) {\r\n    currentMarqueeState = (state == true) ? 1 : 0;\r\n  }\r\n}\r\nvoid setChassisFanSpeed(int speed) {\r\n  currentFanSpeed = map(speed, 0, 100, 0, 255);\r\n  analogWrite(fanPWM, currentFanSpeed);\r\n}\r\nvoid setGameDisk(int number) {\r\n  if (number < 10) {\r\n    // Nu Switchover\r\n    inhibitNuState = false;\r\n    nuResponse = \"\";\r\n    while (currentGameSelected0 != number) {\r\n      nuControl.print(\"DS::\");\r\n      nuControl.println(String(number));\r\n      delay(100);\r\n    }\r\n    if (currentPowerState0 == 1) {\r\n      setSysBoardPower(true);\r\n      resetPSU();\r\n      setTouchControl(true);\r\n      setDisplayState(false);\r\n      startingLEDState();\r\n      //startLoadingScreen();\r\n    }\r\n    for (int i = 0; i < 3; i++) {\r\n      cardReaderSerial.println(\"BLOCKER_CLOSE::NO_DATA\");\r\n      delay(100);\r\n    }\r\n  } else {\r\n    // ALLS Switchover\r\n    inhibitNuState = true;\r\n    currentGameSelected0 = number;\r\n    ALLSCtrl(\"DS\", String(number));\r\n    if (currentPowerState0 == 1) {\r\n      allsOK = false;\r\n      pending_alls_good_response = (currentGameSelected0 == 20);\r\n      for (int i = 0; i < 3; i++) {\r\n        cardReaderSerial.println(\"BLOCKER_CLOSE::NO_DATA\");\r\n        delay(100);\r\n      }\r\n      setSysBoardPower(true);\r\n      resetPSU();\r\n      setTouchControl(false);\r\n      setDisplayState(true);\r\n      startingLEDState();\r\n      //startLoadingScreen();\r\n    }\r\n  }\r\n  messageIcon = 129;\r\n  messageText = \"HDD: \";\r\n  switch (number) {\r\n    case 0:\r\n      messageText += \"PL Omni (Nu)\";\r\n      break;\r\n    case 1:\r\n      messageText += \"PL Base (Nu)\";\r\n      break;\r\n    case 2:\r\n      messageText += \"Air+ (Nu)\";\r\n      break;\r\n    case 3:\r\n      messageText += \"Star+ (Nu)\";\r\n      break;\r\n    case 4:\r\n      messageText += \"Crystal+ (Nu)\";\r\n      break;\r\n    case 5:\r\n      messageText += \"Other? (Nu)\";\r\n      break;\r\n    case 10:\r\n      messageText += \"Sun+ (ALLS)\";\r\n      break;\r\n    case 11:\r\n      messageText += \"New+ (ALLS)\";\r\n      break;\r\n    case 20:\r\n      messageText += \"DIVA: FT (ALLS)\";\r\n      break;\r\n    default:\r\n      messageText += \"???\";\r\n      break;\r\n  }\r\n  invertMessage = (currentPowerState0 == 1);\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  timeoutMessage = 10;\r\n  typeOfMessage = 1;\r\n}\r\nvoid setDisplayState(bool state) {\r\n  if (state != displayMainState) {\r\n    pushDisplaySwitch();\r\n  }\r\n}\r\nvoid setEthernetState(int ethNum, int ethVal) {\r\n  if (digitalRead(ethSensors[ethNum]) == ((ethVal == 1) ? LOW : HIGH)) {\r\n    if (ethNum == 0 && currentPowerState0 == 1) {\r\n      nuResponse = \"\";\r\n      while (nuResponse == \"\") {\r\n        nuControl.println(\"PS::128\");\r\n        delay(100);\r\n      }\r\n      if (pending_release_display == false) {\r\n        setDisplayState(true);\r\n        startLoadingScreen();\r\n      }\r\n    }\r\n    if (ethNum == 0) {\r\n      messageIcon = 270;\r\n      messageText = \"Network: \";\r\n      switch (ethVal) {\r\n        case 0:\r\n          messageText += \"Official\";\r\n          break;\r\n        case 1:\r\n          messageText += \"Missless\";\r\n          break;\r\n        default:\r\n          messageText += \"???\";\r\n          break;\r\n      }\r\n      invertMessage = (currentPowerState0 == 1);\r\n      isJpnMessage = false;\r\n      brightMessage = 255;\r\n      timeoutMessage = 10;\r\n      typeOfMessage = 1;\r\n    }\r\n    pushEthSwitch(ethNum);\r\n  }\r\n}\r\nvoid triggerLEDUpdate() {\r\n  if (currentPowerState0 == 1) {\r\n    String req = \"LED_DATA::\";\r\n    if (currentGameSelected0 >= 20) {\r\n      req += \"128\";\r\n    } else {\r\n      req += \"255\";\r\n    }\r\n    req += \"::4::\";\r\n    switch (currentGameSelected0) {\r\n      case 0:\r\n      case 1:\r\n        // PLOST\r\n        req += \"00FF59 00F460 00EA68 00DF6F 00D577 00CA7E 00C085 00B58D 00AA94 00A09B 0095A3 008BAA 0080B2 0075B9 006BC0 0060C8 0056CF 004BD6 0041DE 0036E5 002BED 0021F4 0016FB 0411FF 0D10FF 160FFF 1F0EFF 280EFF 310DFF 3A0CFF 430BFF 4C0BFF 540AFF 5D09FF 6608FF 6F08FF 7807FF 8106FF 8A05FF 9305FF 9C04FF A403FF AD02FF B602FF BF01FF::\";\r\n        break;\r\n      case 2:\r\n        // Star\r\n        req += \"00B3FF 00AEFF 00A9FF 00A4FF 009FFF 0099FF 0094FF 008FFF 008AFF 0085FF 0080FF 007BFF 0076FF 0071FF 006BFF 0066FF 0061FF 005CFF 0057FF 0052FF 004DFF 0048FF 0043FF 0644FF 114DFF 1C55FF 285EFF 3366FF 3E6FFF 4A77FF 5580FF 6088FF 6C91FF 7799FF 82A2FF 8EAAFF 99B3FF A4BBFF B0C4FF BBCCFF C6D5FF D2DDFF DDE6FF E8EEFF F4F7FF::\";\r\n        break;\r\n      case 3:\r\n        // Air\r\n        req += \"FFA21F FFA01E FF9F1C FF9D1B FF9B19 FF9918 FF9817 FF9615 FF9414 FF9213 FF9111 FF8F10 FF8D0E FF8B0D FF8A0C FF880A FF8609 FF8508 FF8306 FF8105 FF7F03 FF7E02 FF7C01 FF7A00 FF7900 FF7700 FF7600 FF7400 FF7300 FF7100 FF7000 FF6E00 FF6D00 FF6B00 FF6A00 FF6800 FF6700 FF6500 FF6400 FF6200 FF6100 FF5F00 FF5E00 FF5C00 FF5B00::\";\r\n        break;\r\n      case 5:\r\n        // Crystal\r\n        req += \"0040FF 003FFF 003EFF 003DFF 003CFF 003BFF 003AFF 0039FF 0038FF 0037FF 0036FF 0035FF 0034FF 0033FF 0032FF 0031FF 0030FF 002FFF 002EFF 002DFF 002CFF 002BFF 002AFF 0329FF 0927FF 1025FF 1623FF 1C22FF 2220FF 281EFF 2F1CFF 351AFF 3B18FF 4116FF 4815FF 4E13FF 5411FF 5A0FFF 600DFF 670BFF 6D09FF 7307FF 7906FF 8004FF 8602FF::\";\r\n        break;\r\n      case 10:\r\n        // Sun\r\n        req += \"48CAFF::\";\r\n        break;\r\n      case 11:\r\n        // New\r\n        req += \"FFFF00::\";\r\n        break;\r\n      case 20:\r\n        // DIVA FT\r\n        req += \"00FBFF 0BF0F8 17E5F1 22DAEB 2DCEE4 39C3DD 44B8D6 4FADCF 5BA2C9 6697C2 718BBB 7D80B4 8875AD 936AA7 9F5FA0 AA5499 B54992 C13D8B CC3285 D7277E E31C77 EE1170 F90669 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066 FF0066::\";\r\n        break;\r\n      default:\r\n        req += \"000000::\";\r\n        break;\r\n    }\r\n    if (coinEnable == true) {\r\n      req += \"-1::\";\r\n    } else {\r\n      req += \"1::\";\r\n    }\r\n    Serial.println(req);\r\n  } else {\r\n    Serial.println(\"LED_DATA::16::0::000000::\");\r\n  }\r\n}\r\nvoid resetState() {\r\n  previousInactivityMillis = millis();\r\n  previousShutdownMillis = millis();\r\n  inactivityMinTimeout = defaultInactivityMinTimeout;\r\n\r\n  startMelody = false;\r\n  melodyPlay = -1;\r\n  loopMelody = -1;\r\n  currentNote = 0;\r\n  previousMelodyMillis = 0;\r\n\r\n  pending_release_leds = false;\r\n  pending_release_display = false;\r\n  pending_alls_good_response = false;\r\n  transition_leds = false;\r\n  animation_state = -1;\r\n  animation_mode = -1;\r\n  currentStep = 0;\r\n  requestedPowerState0 = -1;\r\n\r\n  setLEDControl(!(currentPowerState0 == 1 && currentGameSelected0 < 20));\r\n  if (currentLEDState == 0) {\r\n    delay(800);\r\n    copyLEDBuffer();\r\n  }\r\n  triggerLEDUpdate();\r\n  setDisplayState((currentGameSelected0 >= 10 && currentPowerState0 == 1) || (currentPowerState0 != 1));\r\n  kioskModeRequest(\"ResetState\");\r\n  if (currentGameSelected0 == 20) {\r\n    for (int i = 0; i < 3; i++) {\r\n      cardReaderSerial.println(\"BLOCKER_OPEN::NO_DATA\");\r\n      delay(100);\r\n    }\r\n    pdaLEDState();\r\n  }\r\n}\r\nvoid resetInactivityTimer() {\r\n  previousInactivityMillis = millis();\r\n  previousShutdownMillis = millis();\r\n  inactivityMinTimeout = defaultInactivityMinTimeout + 20;\r\n  resetState();\r\n}\r\n\r\nvoid pushEthSwitch(int ethNum) {\r\n  digitalWrite(ethButtons[ethNum], HIGH);\r\n  digitalWrite(ethButtons[ethNum], LOW);\r\n  delay(150);\r\n  digitalWrite(ethButtons[ethNum], HIGH);\r\n}\r\nvoid pushDisplaySwitch() {\r\n  digitalWrite(displayMainSelect, HIGH);\r\n  digitalWrite(displayMainSelect, LOW);\r\n  delay(500);\r\n  digitalWrite(displayMainSelect, HIGH);\r\n}\r\n\r\nvoid ALLSCtrl(String command, String data) {\r\n  Serial.println(\"\");\r\n  Serial.print(command);\r\n  Serial.print(\"::\");\r\n  Serial.print(data);\r\n  Serial.println(\"\");\r\n}\r\nvoid kioskModeRequest(String command) {\r\n  Serial.println(\"\");\r\n  Serial.println(\"ACTION::\" + command);\r\n  Serial.println(\"\");\r\n}\r\nvoid kioskTest() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool messageStarted = false;\r\n\r\n\r\n  while (ready_to_boot == false) {\r\n    while (Serial.available()) {\r\n      c = Serial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"PROBE\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"HELLO\") {\r\n                int softwareIndex = receivedMessage.indexOf(\"::\", valueIndex + 2);\r\n                attachedSoftwareCU = receivedMessage.substring(valueIndex + 2, softwareIndex);\r\n                ready_to_boot = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n  if(Task3 != NULL) {\r\n    vTaskDelete(Task3);\r\n  }\r\n}\r\nvoid testCardReader() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool card_reader_txrx_ok = false;\r\n\r\n\r\n  while (card_reader_txrx_ok == false) {\r\n    while (cardReaderSerial.available()) {\r\n      c = cardReaderSerial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"HELLO\") {\r\n              card_reader_txrx_ok = true;\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}\r\nvoid kioskCommand() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool messageStarted = false;\r\n\r\n  for(;;) {\r\n    while (Serial.available()) {\r\n      c = Serial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"POWER_SWITCH\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"OFF\") {\r\n                setMasterPowerOff();\r\n              } else if (valueString == \"STANDBY\") {\r\n                if (currentPowerState0 == 1) {\r\n                  setGameOff();\r\n                } else if (currentPowerState0 == -1) {\r\n                  setMasterPowerOn();\r\n                }\r\n              } else if (valueString == \"ON\") {\r\n                setGameOn();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + getPowerAuth());\r\n              }\r\n            } else if (header == \"POWER_REQUEST\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"OFF\") {\r\n                requestPowerOff();\r\n              } else if (valueString == \"STANDBY_NA\") {\r\n                if (currentPowerState0 == 1) {\r\n                  setGameOn();\r\n                } else if (currentPowerState0 == -1) {\r\n                  setMasterPowerOn();\r\n                }\r\n              } else if (valueString == \"STANDBY\") {\r\n                requestStandby();\r\n              } else if (valueString == \"ON\") {\r\n                setGameOn();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((requestedPowerState0 == -1) ? \"Power Off\" : (requestedPowerState0 == 0) ? \"Standby\" : \"None\"));\r\n              }\r\n            } else if (header == \"INACTIVITY_TIMER\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"RESET\") {\r\n                resetInactivityTimer();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((currentPowerState0 == 1 && inactivityTimeout == true) ? String(inactivityMinTimeout - ((millis() - previousInactivityMillis) / 1000)) : \"0\"));\r\n              }\r\n            } else if (header == \"SHUTDOWN_TIMER\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((currentPowerState0 == 1) ? String(shutdownDelayMinTimeout - ((millis() - previousShutdownMillis) / 1000)) : \"0\"));\r\n              }\r\n            } else if (header == \"DISK_SELECT\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + getGameSelect());\r\n              } else {\r\n                int valueInt = valueString.toInt();\r\n                setGameDisk(valueInt);\r\n              }\r\n            } else if (header == \"NETWORK_SELECT\") {\r\n              int cabIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String cabString = receivedMessage.substring(headerIndex + 2, cabIndex);\r\n              int valueIndex = receivedMessage.indexOf(\"::\", cabIndex + 2);\r\n              String valueString = receivedMessage.substring(cabIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n                String res = \"INVALID\";\r\n                if (cabString == \"CHUNITHM\") {\r\n                  res = getEthSwitchVal(0);\r\n                } else if (cabString == \"WACCA\") {\r\n                  res = getEthSwitchVal(1);\r\n                }\r\n                Serial.println(\"R::\" + res);\r\n              } else {\r\n                if (cabString == \"CHUNITHM\") {\r\n                  int valueInt = valueString.toInt();\r\n                  if (valueInt >= 0 && valueInt <= 1) {\r\n                    setEthernetState(0, valueInt);\r\n                  }\r\n                } else if (cabString == \"WACCA\") {\r\n                  int valueInt = valueString.toInt();\r\n                  if (valueInt >= 0 && valueInt <= 1) {\r\n                    setEthernetState(1, valueInt);\r\n                  }\r\n                }\r\n              }\r\n            } else if (header == \"STATE\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"RESET\") {\r\n                resetState();\r\n              }\r\n            } else if (header == \"VOLUME\") {\r\n              int optionIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String optionString = receivedMessage.substring(headerIndex + 2, optionIndex);\r\n              if (optionString == \"?\") {\r\n                Serial.println(\"R::\" + ((muteVolume == true) ? \"Muted\" : String(map(currentVolume, minimumVolume, maximumVolume, 0, 100))));\r\n              } else if (optionString == \"SET\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 100) {\r\n                  currentVolume = map(valueInt, 0, 100, minimumVolume, maximumVolume);\r\n                  muteVolume = false;\r\n                  ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                  displayVolumeMessage();\r\n                }\r\n              } else if (optionString == \"UP\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n                current_percent += valueInt;\r\n                currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n                muteVolume = false;\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"DOWN\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n                current_percent -= valueInt;\r\n                currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n                muteVolume = false;\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE_ON\") {\r\n                muteVolume = true;\r\n                ds3502.setWiper(minimumVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE_OFF\") {\r\n                muteVolume = false;\r\n                ds3502.setWiper(currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE\") {\r\n                muteVolume = !(muteVolume);\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              }\r\n            } else if (header == \"PING\") {\r\n              Serial.println(\"R::PONG\");\r\n            } else if (header == \"ALLS_OK\") {\r\n              allsOK = true;\r\n            } else if (header == \"ALLS_NG\") {\r\n              allsOK = false;\r\n            } else if (header == \"DISPLAY_MESSAGE\") {\r\n              // DISPLAY_MESSAGE::BIG::icon::text::isJP/t::255::invert/t::timeout/20\r\n              int iconIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              messageIcon = (receivedMessage.substring(headerIndex + 2, iconIndex)).toInt();\r\n              int messageIndex = receivedMessage.indexOf(\"::\", iconIndex + 2);\r\n              messageText = receivedMessage.substring(iconIndex + 2, messageIndex);\r\n              int isJpnIndex = receivedMessage.indexOf(\"::\", messageIndex + 2);\r\n              isJpnMessage = ((receivedMessage.substring(messageIndex + 2, isJpnIndex)).toInt() == 1);\r\n              int brightIndex = receivedMessage.indexOf(\"::\", isJpnIndex + 2);\r\n              brightMessage = (receivedMessage.substring(isJpnIndex + 2, brightIndex)).toInt();\r\n              int invertIndex = receivedMessage.indexOf(\"::\", brightIndex + 2);\r\n              invertMessage = ((receivedMessage.substring(brightIndex + 2, invertIndex)).toInt() == 1);\r\n              int timeoutIndex = receivedMessage.indexOf(\"::\", invertIndex + 2);\r\n              timeoutMessage = (receivedMessage.substring(invertIndex + 2, timeoutIndex)).toInt();\r\n              int typeIndex = receivedMessage.indexOf(\"::\", timeoutIndex + 2);\r\n              typeOfMessage = (receivedMessage.substring(timeoutIndex + 2, typeIndex)).toInt();\r\n            } else if (header == \"LED_DATA\") {\r\n              // LED_DATA::bank_id::brightness::time::take_own::is_stream::hex_data::\r\n              int bankIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              int bankSelect = (receivedMessage.substring(headerIndex + 2, bankIndex)).toInt();\r\n              int brightIndex = receivedMessage.indexOf(\"::\", bankIndex + 2);\r\n              int brightValue = (receivedMessage.substring(bankIndex + 2, brightIndex)).toInt();\r\n              int timeIndex = receivedMessage.indexOf(\"::\", brightIndex + 2);\r\n              float timeValue = (receivedMessage.substring(brightIndex + 2, timeIndex)).toFloat();\r\n              bool hasTransition = (timeValue > 0);\r\n              int ownershipIndex = receivedMessage.indexOf(\"::\", timeIndex + 2);\r\n              bool takeOwnership = ((receivedMessage.substring(timeIndex + 2, ownershipIndex)).toInt() == 1);\r\n              int isStreamIndex = receivedMessage.indexOf(\"::\", ownershipIndex + 2);\r\n              bool isStream = ((receivedMessage.substring(ownershipIndex + 2, isStreamIndex)).toInt() == 1);\r\n              int dataIndex = receivedMessage.indexOf(\"::\", isStreamIndex + 2);\r\n              String ledValues = receivedMessage.substring(isStreamIndex + 2, dataIndex);\r\n              if ((pending_release_leds == false && currentPowerState0 != 1) || takeOwnership) {\r\n                int brightness = 64;\r\n                if (brightValue != -1) {\r\n                  if (brightValue > 0 && brightValue <= 255) {\r\n                    if (hasTransition) {\r\n                      targetBrightness = brightValue;\r\n                    } else {\r\n                      NeoPixelL.setBrightness(brightValue);\r\n                      NeoPixelR.setBrightness(brightValue);\r\n                    }\r\n                  }\r\n                }\r\n                if (takeOwnership) {\r\n                  setLEDControl((server.arg(\"ledValues\").c_str() == \"true\"));\r\n                }\r\n                if (hasTransition) {\r\n                  numSteps = timeValue * 33.2;\r\n                  transition_interval = (unsigned long)(1000.0 * timeValue / (float)numSteps);\r\n                }\r\n                \r\n                if (isStream) {\r\n                  handleSetLeds(ledValues, bankSelect, hasTransition);\r\n                } else {\r\n                  handleSetLedColor(ledValues, bankSelect, hasTransition);\r\n                }\r\n              }\r\n            } else if (header == \"SYS_STATE\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n\r\n              } else {\r\n                int valueInt = valueString.toInt();\r\n                switch (valueInt) {\r\n                  case 10: {\r\n                    int stateIndex = receivedMessage.indexOf(\"::\", valueIndex + 2);\r\n                    String stateString = receivedMessage.substring(valueIndex + 2, stateIndex);\r\n                    currentALLSState0 = stateString.toInt();\r\n                    break;\r\n                  }\r\n                  default:\r\n                    break;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Chunithm-AllInOne-ESP32/Chunithm-AllInOne-ESP32.ino b/Chunithm-AllInOne-ESP32/Chunithm-AllInOne-ESP32.ino
--- a/Chunithm-AllInOne-ESP32/Chunithm-AllInOne-ESP32.ino	(revision df7a14d0149c1334c5c0f2cfd9fd7d796c32b200)
+++ b/Chunithm-AllInOne-ESP32/Chunithm-AllInOne-ESP32.ino	(date 1710959181233)
@@ -40,7 +40,7 @@
 HardwareSerial cardReaderSerial(2);
 bool coinEnable = false;
 bool allsOK = false;
-bool has_cr_talked = false;
+bool has_cr_talked = false; 
 // Display Switch
 // 23 - Select
 // 15 - State
Index: .idea/discord.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"DiscordProjectSettings\">\r\n    <option name=\"show\" value=\"ASK\" />\r\n    <option name=\"description\" value=\"\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/discord.xml b/.idea/discord.xml
--- a/.idea/discord.xml	(revision df7a14d0149c1334c5c0f2cfd9fd7d796c32b200)
+++ b/.idea/discord.xml	(date 1711219302466)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="DiscordProjectSettings">
-    <option name="show" value="ASK" />
+    <option name="show" value="PROJECT_FILES" />
     <option name="description" value="" />
   </component>
 </project>
\ No newline at end of file
Index: WACCA/WACCA.ino
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <WiFi.h>\r\n#include <WebServer.h>\r\n#include <HTTPClient.h>\r\n#include <EEPROM.h>\r\n#include <U8g2lib.h>\r\n#include <Adafruit_DS3502.h>\r\n#include <FastLED.h>\r\n#include <SoftwareSerial.h>\r\n#include \"melody.h\"\r\n\r\nconst char* ssid = \"Radio Noise AX\";\r\nconst char* password = \"Radio Noise AX\";\r\nWebServer server(80);\r\n\r\n// Power Controls\r\n// 0 - Green - Display + PSU Enable\r\n// 1 - Yellow - LED Select (Default ESP)\r\n// 2 - Orange - LED 5V Enable\r\n// 3 - Red - ALLS Power\r\n// 4 - Red - IO 12V/5V Enable\r\n// 5 - White - Marquee\r\nint relayPins[6] = { 12, 14, 27, 26, 18, 25 };\r\nint numRelays = 6;\r\n// ALLS CONTROL PORT (\"Wide\" Pin Version)\r\n// UART Serial to Arduino Nano\r\nEspSoftwareSerial::UART nuControl;\r\nconst int nuControlTX = 15; // WHITE RED\r\nconst int nuControlRX = 5; // WHITE GREEN\r\nString nuResponse = \"\";\r\n// Fan Controller\r\nconst int fanPWM1 = 19;\r\nconst int fanPWM2 = 32;\r\n// Aux\r\n// Card Reader Communication\r\nHardwareSerial cardReaderSerial(2);\r\nbool coinEnable = false;\r\nbool has_cr_talked = false;\r\n// Display Switch\r\n// 23 - Select\r\n// 15 - State\r\nconst int displayMainSelect = 23;\r\nconst int displayMainLDR = 36;\r\nbool displayMainState = false;\r\n// WACCA LED Controls\r\n#define ledOutput 13\r\n#define NUM_LEDS 480 // 8 x 5 x 12 (8 Col, 60 Rows)\r\nCRGB leds[NUM_LEDS];\r\nCRGB leds_source[NUM_LEDS];\r\nCRGB leds_target[NUM_LEDS];\r\nCRGBPalette16 currentPalette;\r\nTBlendType currentBlendType = LINEARBLEND;\r\nuint8_t sourceBrightness = 0;\r\nuint8_t targetBrightness = 0;\r\n// Beeper Tones\r\nint buzzer_pin = 33;\r\nunsigned long previousMelodyMillis = 0;\r\nint currentNote = 0;\r\nint melodyPlay = 2;\r\nbool startMelody = true;\r\nint loopMelody = -1;\r\nint pauseBetweenNotes = 0;\r\nint booting_tone[] = {\r\n  NOTE_C5, NOTE_E5, NOTE_D5, NOTE_C6, NOTE_E6\r\n};\r\nint booting_tone_dur[] = {\r\n  8, 8, 8, 4, 2\r\n};\r\n\r\nint shutting_down_tone[] = {\r\n  NOTE_D5, NOTE_A4, NOTE_D5, NOTE_D4\r\n};\r\nint shutting_down_dur[] = {\r\n  8, 8, 4, 2\r\n};\r\nint warning_tone_long[] = {\r\n  NOTE_A5, NOTE_F5\r\n};\r\nint warning_tone_long_dur[] = {\r\n  4, 4\r\n};\r\nint warning_tone[] = {\r\n  NOTE_A5, NOTE_G5, NOTE_F5\r\n};\r\nint warning_tone_dur[] = {\r\n  8, 8, 8\r\n};\r\nint boot_tone[] = {\r\n  NOTE_F5, NOTE_G5, NOTE_A5, NOTE_B5\r\n};\r\nint boot_tone_dur[] = {\r\n  8, 8, 8, 4\r\n};\r\n// Occupancy and Timer\r\nint requestedPowerState0 = -1;\r\nint defaultInactivityMinTimeout = 45;\r\nint inactivityMinTimeout = 45;\r\nconst int shutdownDelayMinTimeout = 5;\r\nunsigned long previousInactivityMillis = 0; \r\nunsigned long previousShutdownMillis = 0; \r\nbool inactivityTimeout = true;\r\n\r\n// DISPLAY_MESSAGE::BIG::icon::text::isJP/t::255::invert/t::timeout/20\r\nint typeOfMessage = -1;\r\nint messageIcon = 0;\r\nString messageText = \"\";\r\nbool isJpnMessage = false;\r\nint brightMessage = 1;\r\nbool invertMessage = false;\r\nint timeoutMessage = 0;\r\n\r\nunsigned long previousMillis = 0; \r\nuint8_t numSteps = 120; // Number of steps in the transition\r\nuint8_t currentStep = 0;\r\nbool pending_release_leds = false;\r\nbool pending_release_display = false;\r\nbool transition_leds = false;\r\nfloat transition_interval = 0;\r\nint animation_mode = -1;\r\nint animation_state = -1;\r\n\r\nbool ready_to_boot = false;\r\nString inputString = \"\"; \r\nString attachedSoftwareCU = \"Unknown\";\r\nint currentVolume = 0;\r\nbool muteVolume = false;\r\nint minimumVolume = 10;\r\nint maximumVolume = 127;\r\nbool inhibitNuState = false;\r\nint currentGameSelected0 = -1;\r\nint requestedGameSelected0 = 0;\r\nint currentNuPowerState0 = -1;\r\nint currentNuBoardState0 = -1;\r\nbool enhancedStandby = false;\r\nint currentALLSLANMode0 = 0;\r\nint currentPowerState0 = -1;\r\nint currentLEDState = 0;\r\nint currentMarqueeState = 1;\r\nint currentFan1Speed = 128;\r\nint currentFan2Speed = 128;\r\nint displayedSec = 0;\r\nint displayState = -1;\r\nU8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0);\r\nAdafruit_DS3502 ds3502 = Adafruit_DS3502();\r\nTaskHandle_t Task1;\r\nTaskHandle_t Task2;\r\nTaskHandle_t Task3;\r\nTaskHandle_t Task4;\r\nTaskHandle_t Task5;\r\nTaskHandle_t Task6;\r\nTaskHandle_t Task7;\r\nTaskHandle_t Task8;\r\nTaskHandle_t Task9;\r\n\r\nconst char *shutdown_url = \"http://192.168.100.32:9052/shutdown\";\r\n\r\nvoid checkWiFiConnection() {\r\n  if (WiFi.status() != WL_CONNECTED) {\r\n    Serial.println(\"WiFi not connected. Attempting to reconnect...\");\r\n    WiFi.hostname(\"CabinetManager\");\r\n    WiFi.disconnect(true);\r\n    WiFi.begin(ssid, password);\r\n    WiFi.setAutoReconnect(true);\r\n    WiFi.persistent(true);\r\n    int tryCount = 0;\r\n    tone(buzzer_pin, NOTE_CS5, 1000 / 8);\r\n    while (WiFi.status() != WL_CONNECTED) {\r\n      //if (tryCount > 60 && currentPowerState0 != 1) {\r\n      //  ESP.restart();\r\n      //}\r\n      tone(buzzer_pin, (tryCount % 2 == 0) ? NOTE_GS5 : NOTE_CS5, 1000 / 8);\r\n      delay(500);\r\n      Serial.print(\".\");\r\n      tryCount++;\r\n    }\r\n    noTone(buzzer_pin);\r\n    Serial.println(\"\\nConnected to WiFi\");\r\n    Serial.print(\"IP address: \");\r\n    Serial.println(WiFi.localIP());\r\n  }\r\n}\r\n\r\nvoid setup() {\r\n  pinMode(displayMainSelect, OUTPUT);\r\n  digitalWrite(displayMainSelect, HIGH);\r\n  inputString.reserve(200); \r\n  attachedSoftwareCU.reserve(200); \r\n  Serial.begin(115200);\r\n  u8g2.begin();\r\n  u8g2.enableUTF8Print();\r\n  bootScreen(\"HappyCAB MCU\");\r\n\r\n  bootScreen(\"HARDWARE\");\r\n  for (int i = 0; i < numRelays; i++) {\r\n    pinMode(relayPins[i], OUTPUT);\r\n    digitalWrite(relayPins[i], LOW);\r\n  }\r\n  if (!ds3502.begin()) {\r\n    Serial.println(\"Couldn't find DS3502 chip\");\r\n    bootScreen(\"I2C VOL FAILURE\");\r\n  }\r\n  FastLED.addLeds<WS2812, ledOutput, GRB>(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);;\r\n  FastLED.setBrightness(64);\r\n  pinMode(displayMainLDR, INPUT);\r\n  pinMode(fanPWM1, OUTPUT);\r\n  pinMode(fanPWM2, OUTPUT);\r\n\r\n  tone(buzzer_pin, NOTE_C6);\r\n  bootScreen(\"NU_CTRL_COM\");\r\n  nuControl.begin(4800, SWSERIAL_8N1, nuControlRX, nuControlTX, false);\r\n  if (!nuControl) {\r\n    bootScreen(\"NU_COM_FAIL\");\r\n    while (1) { // Don't continue with invalid configuration\r\n      delay (1000);\r\n    }\r\n  }\r\n  xTaskCreatePinnedToCore(\r\n                  nuControlRXLoop,   /* Task function. */\r\n                  \"nuControlRX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task6,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  while (nuResponse.substring(0,1) != \"P\") {\r\n    delay(500);\r\n    nuControl.println(\"P::\");\r\n  }\r\n  nuResponse = \"\";\r\n  while (nuResponse == \"\") {\r\n    nuControl.println(\"PS::0\");\r\n    delay(100);\r\n  }\r\n  nuResponse = \"\";\r\n\r\n  bootScreen(\"PC_LINK\");\r\n  xTaskCreatePinnedToCore(\r\n                    pingLoop,   /* Task function. */\r\n                    \"pingTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    1,           /* priority of the task */\r\n                    &Task3,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  kioskTest();\r\n\r\n  bootScreen(\"CARD_LINK\");\r\n  cardReaderSerial.begin(9600, SERIAL_8N1, 16, 17);\r\n  if (!cardReaderSerial) {\r\n    bootScreen(\"CARDREADER_FAIL_1\");\r\n    while (1) { // Don't continue with invalid configuration\r\n      delay (1000);\r\n    }\r\n  }\r\n  noTone(buzzer_pin);\r\n  delay(500);\r\n\r\n  bootScreen(\"NETWORK\");\r\n  checkWiFiConnection();\r\n\r\n  tone(buzzer_pin, NOTE_C6);\r\n  bootScreen(\"RST_READER\");\r\n  for (int i = 0; i < 3; i++) {\r\n    cardReaderSerial.println(\"REBOOT::NO_DATA\");\r\n    delay(100);\r\n  }\r\n  testCardReader();\r\n  noTone(buzzer_pin);\r\n\r\n  bootScreen(\"DEFAULTS\");\r\n  currentVolume = map(25, 0, 100, minimumVolume, maximumVolume);\r\n  ds3502.setWiper(currentVolume);\r\n  ds3502.setWiperDefault(currentVolume);\r\n  kioskModeRequest(\"StopAll\");\r\n  displayMainState = (digitalRead(displayMainLDR) == LOW);\r\n  delay(2000);\r\n\r\n  bootScreen(\"REMOTE_ACCESS\");\r\n  server.on(\"/volume/set\", [=]() {\r\n    int _currentVolume = currentVolume;\r\n    if (server.hasArg(\"wiper\")) {\r\n      int _volVal = server.arg(\"wiper\").toInt();\r\n      if (_volVal > 0 && _volVal <= 127) {\r\n        currentVolume = _volVal;\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(currentVolume));\r\n      }\r\n    } else if (server.hasArg(\"down\")) {\r\n      int _volVal = server.arg(\"down\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        current_percent -= _volVal;\r\n        currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(current_percent));\r\n      }\r\n    } else if (server.hasArg(\"up\")) {\r\n      int _volVal = server.arg(\"up\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        current_percent += _volVal;\r\n        currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(current_percent));\r\n      }\r\n    } else if (server.hasArg(\"percent\")) {\r\n      int _volVal = server.arg(\"percent\").toInt();\r\n      if (_volVal > 0 && _volVal <= 100) {\r\n        currentVolume = map(_volVal, 0, 100, minimumVolume, maximumVolume);\r\n        muteVolume = false;\r\n        server.send(200, \"text/plain\", String(_volVal));\r\n      }\r\n    } else if (server.hasArg(\"mute\")) {\r\n      String _muteVal = server.arg(\"mute\");\r\n      if (server.hasArg(\"invert\")) {\r\n        muteVolume = (_muteVal != \"true\");\r\n        server.send(200, \"text/plain\", \"OK\");\r\n      } else {\r\n        muteVolume = (_muteVal == \"true\");\r\n        server.send(200, \"text/plain\", \"OK\");\r\n      }\r\n    }\r\n    ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n    if (_currentVolume != currentVolume) {\r\n      displayVolumeMessage();\r\n    }\r\n  });\r\n  server.on(\"/volume\", [=]() {\r\n    String response = \"\";\r\n    if (server.hasArg(\"mute\")) {\r\n      if (server.hasArg(\"invert\")) {\r\n        response += ((muteVolume == true) ? \"0\" : \"1\");\r\n      } else {\r\n        response += ((muteVolume == true) ? \"1\" : \"0\");\r\n      }\r\n    } else {\r\n      response += map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/1/set\", [=]() {\r\n    String response = \"UNCHANGED\";\r\n    int fanSpeed = -1;\r\n    if (server.hasArg(\"percent\")) {\r\n      int _fanVal = server.arg(\"percent\").toInt();\r\n      if (_fanVal > 0 && _fanVal <= 100) {\r\n        fanSpeed = _fanVal;\r\n        response = \"SET TO \";\r\n        response += _fanVal;\r\n        response += \"%\";\r\n      }\r\n    }\r\n    if (fanSpeed > -1) {\r\n      setChassisFanSpeed(fanSpeed);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/2/set\", [=]() {\r\n    String response = \"UNCHANGED\";\r\n    int fanSpeed = -1;\r\n    if (server.hasArg(\"percent\")) {\r\n      int _fanVal = server.arg(\"percent\").toInt();\r\n      if (_fanVal > 0 && _fanVal <= 100) {\r\n        fanSpeed = _fanVal;\r\n        response = \"SET TO \";\r\n        response += _fanVal;\r\n        response += \"%\";\r\n      }\r\n    }\r\n    if (fanSpeed > -1) {\r\n      setMainFanSpeed(fanSpeed);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/1/reset\", [=]() {\r\n    String response = \"OK\";\r\n    if (currentPowerState0 == 0) {\r\n      setChassisFanSpeed(35);\r\n    } else if (currentPowerState0 == -1) {\r\n      setChassisFanSpeed(0);\r\n    } else if (currentPowerState0 == 1) {\r\n      setChassisFanSpeed(75);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/2/reset\", [=]() {\r\n    String response = \"OK\";\r\n    if (currentPowerState0 == 0) {\r\n      setMainFanSpeed((enhancedStandby == true) ? 100 : 25);\r\n    } else if (currentPowerState0 == -1) {\r\n      setMainFanSpeed((enhancedStandby == true) ? 75 : 15);\r\n    } else if (currentPowerState0 == 1) {\r\n      setMainFanSpeed(100);\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/1\", [=]() {\r\n    String response = \"\";\r\n    response += map(currentFan1Speed, 0, 255, 0, 100);\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n  server.on(\"/fan/2\", [=]() {\r\n    String response = \"\";\r\n    response += map(currentFan2Speed, 0, 255, 0, 100);\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n\r\n  server.on(\"/display/pc\", [=]() {\r\n    setDisplayState(true);\r\n    server.send(200, \"text/plain\", (displayMainSelect == true) ? \"UNCHANGED\" : \"OK\");\r\n  });\r\n  server.on(\"/display/game\", [=]() {\r\n    setDisplayState(false);\r\n    server.send(200, \"text/plain\", (displayMainSelect == false) ? \"UNCHANGED\" : \"OK\");\r\n  });\r\n  server.on(\"/display/switch\", [=]() {\r\n    String assembledOutput = \"\";\r\n    pushDisplaySwitch();\r\n    assembledOutput += ((displayMainSelect == false) ? \"PC\" : \"AUX\");\r\n    server.send(200, \"text/plain\", assembledOutput);\r\n  });\r\n  server.on(\"/display\", [=]() {\r\n    String assembledOutput = \"\";\r\n    assembledOutput += ((displayMainSelect == true) ? \"PC\" : \"GAME\");\r\n    server.send(200, \"text/plain\", assembledOutput);\r\n  });\r\n\r\n  server.on(\"/select/game/reverse\", [=]() {\r\n    if (currentGameSelected0 != 0) {\r\n      requestedGameSelected0 = 0;\r\n      if (enhancedStandby == false || currentPowerState0 == 1) {\r\n        setGameDisk(0);\r\n      }\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game/lilly\", [=]() {\r\n    if (currentGameSelected0 != 1) {\r\n      requestedGameSelected0 = 1;\r\n      if (enhancedStandby == false || currentPowerState0 == 1) {\r\n        setGameDisk(1);\r\n      }\r\n      server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"REBOOTING\" : \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/select/game\", [=]() {\r\n    String const val = getGameSelect();\r\n    server.send(200, \"text/plain\", val);\r\n  });\r\n  \r\n  server.on(\"/power/off\", [=]() {\r\n    server.send(200, \"text/plain\", (currentPowerState0 == -1) ? \"UNCHNAGED\" : \"OK\");\r\n    setMasterPowerOff();\r\n    currentPowerState0 = -1;\r\n  });\r\n  server.on(\"/power/standby\", [=]() {\r\n    if (currentPowerState0 == 1) {\r\n      setGameOff();\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else if (currentPowerState0 == -1 || (currentPowerState0 == 0 && currentNuPowerState0 != ((enhancedStandby == true) ? 1 : 0))) {\r\n      setMasterPowerOn();\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/power/on\", [=]() {\r\n    server.send(200, \"text/plain\", (currentPowerState0 == 1) ? \"UNCHNAGED\" : \"OK\");\r\n    setGameOn();\r\n  });\r\n  server.on(\"/request/standby\", [=]() {\r\n    server.send(200, \"text/plain\", \"OK\");\r\n    if (currentPowerState0 == 1 && coinEnable == false) {\r\n      if (server.hasArg(\"nonauthoritive\")) {\r\n      } else {\r\n        setGameOff();\r\n      }\r\n    } else if (currentPowerState0 == 1 && coinEnable == true) {\r\n      if (server.hasArg(\"nonauthoritive\")) {\r\n      } else {\r\n        shuttingDownLEDState(1);\r\n      }\r\n    } else if (currentPowerState0 == -1 || (currentPowerState0 == 0 && currentNuPowerState0 != ((enhancedStandby == true) ? 1 : 0))) {\r\n      setMasterPowerOn();\r\n    }\r\n  });\r\n  server.on(\"/request/off\", [=]() {\r\n    server.send(200, \"text/plain\", \"OK\");\r\n    requestPowerOff();\r\n  });\r\n  server.on(\"/enhanced_standby/enable\", [=]() {\r\n    server.send(200, \"text/plain\", (enhancedStandby == true) ? \"UNCHANGED\" : \"OK\");\r\n    enhancedStandby = true;\r\n    if (currentPowerState0 != 1 && currentNuPowerState0 == 0) {\r\n      enterEnhancedStandby(true);\r\n    }\r\n  });\r\n  server.on(\"/enhanced_standby/disable\", [=]() {\r\n    server.send(200, \"text/plain\", (enhancedStandby == false) ? \"UNCHANGED\" : \"OK\");\r\n    enhancedStandby = false;\r\n    if (currentPowerState0 != 1 && currentNuPowerState0 == 1) {\r\n      enterEnhancedStandby(false);\r\n    }\r\n  });\r\n  server.on(\"/enhanced_standby\", [=]() {\r\n    server.send(200, \"text/plain\", (enhancedStandby == true) ? \"Enabled\" : \"Disabled\");\r\n  });\r\n\r\n  server.on(\"/test/alls/off\", [=]() {\r\n    setDisplayState(true);\r\n    if (enhancedStandby == true) {\r\n      enterEnhancedStandby(true);\r\n    } else {\r\n      nuResponse = \"\";\r\n      while (currentNuPowerState0 == 1) {\r\n        nuControl.println(\"PS::0\");\r\n        delay(100);\r\n      }\r\n      digitalWrite(relayPins[3], LOW);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/alls/on\", [=]() {\r\n    setDisplayState(false);\r\n    digitalWrite(relayPins[3], HIGH);\r\n    if (requestedGameSelected0 != currentGameSelected0) {\r\n      setGameDisk(requestedGameSelected0);\r\n    }\r\n    nuResponse = \"\";\r\n    while (currentNuPowerState0 == 0) {\r\n      nuControl.println(\"PS::1\");\r\n      delay(100);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/alls/reset\", [=]() {\r\n    setDisplayState(false);\r\n    int i = 0;\r\n    while (currentGameSelected0 != 2 && i < 5) {\r\n      nuControl.println(\"PS::128\");\r\n      delay(125);\r\n      i++;\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/off\", [=]() {\r\n    setSysBoardPower(false);\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/on\", [=]() {\r\n    setSysBoardPower(true);\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/sysbrd/reset\", [=]() {\r\n    nuResponse = \"\";\r\n    while (nuResponse == \"\") {\r\n      nuControl.println(\"PS::128\");\r\n      delay(100);\r\n    }\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/display_switch/hold\", [=]() {\r\n    digitalWrite(displayMainSelect, HIGH);\r\n    digitalWrite(displayMainSelect, LOW);\r\n    delay(5000);\r\n    digitalWrite(displayMainSelect, HIGH);\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/melody\", [=]() {\r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n  server.on(\"/test/display\", [=]() {\r\n    messageIcon = 223;\r\n    messageText = \"Display Test\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 5;\r\n    typeOfMessage = 1;\r\n    server.send(200, \"text/plain\", \"OK\");\r\n  });\r\n\r\n  server.on(\"/power\", [=]() {\r\n    String const val = getPowerAuth();\r\n    server.send(200, \"text/plain\", val);\r\n  });\r\n  server.on(\"/master_power\", [=]() {\r\n    server.send(200, \"text/plain\", (requestedPowerState0 == 0) ? \"Warning\" : ((currentPowerState0 != -1) ? \"Enabled\" : \"Disabled\"));\r\n  });\r\n  server.on(\"/game_power\", [=]() {\r\n    server.send(200, \"text/plain\", (requestedPowerState0 >= 0) ? \"Warning\" : ((currentPowerState0 == 1) ? \"Enabled\" : \"Disabled\"));\r\n  });\r\n  \r\n  server.on(\"/timeout\", [=]() {\r\n    server.send(200, \"text/plain\", ((inactivityTimeout == true) ? \"ON\" : \"OFF\"));\r\n  });\r\n  server.on(\"/timeout/on\", [=]() {\r\n    if (inactivityTimeout == false) {\r\n      resetInactivityTimer();\r\n      inactivityTimeout = true;\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/timeout/off\", [=]() {\r\n     if (inactivityTimeout == true) {\r\n      inactivityTimeout = false;\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/timeout/set\", [=]() {\r\n    String response = \"UNCHANGED\";\r\n    if (server.hasArg(\"time\")) {\r\n      int _time = server.arg(\"time\").toInt();\r\n      defaultInactivityMinTimeout = _time;\r\n      resetInactivityTimer();\r\n    }\r\n    server.send(200, \"text/plain\", response);\r\n  });\r\n\r\n  server.on(\"/marquee/on\", [=]() {\r\n    if (currentMarqueeState == 0) {\r\n      setMarqueeState(true, true);\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/marquee/off\", [=]() {\r\n    if (currentMarqueeState == 1) {\r\n      setMarqueeState(false, true);\r\n      server.send(200, \"text/plain\", \"OK\");\r\n    } else {\r\n      server.send(200, \"text/plain\", \"UNCHANGED\");\r\n    }\r\n  });\r\n  server.on(\"/marquee\", [=]() {\r\n    server.send(200, \"text/plain\", ((currentMarqueeState == 0) ? (currentPowerState0 == 1) ? \"Enabled\" : \"Disabled\" : \"Enabled\"));\r\n  });\r\n  \r\n  server.on(\"/setLED\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Data Sent\");\r\n    if (pending_release_leds == false && currentPowerState0 != 1) {\r\n      int brightness = 64;\r\n      int bankSelect = 0;\r\n      if (server.hasArg(\"ledBrightness\")) {\r\n        brightness = server.arg(\"ledBrightness\").toInt();\r\n        if (brightness > 0 && brightness <= 255) {\r\n          if (server.hasArg(\"transition_time\")) {\r\n            targetBrightness = brightness;\r\n          } else {\r\n            FastLED.setBrightness(brightness);\r\n          }\r\n          Serial.println(\"Set brightness to: \" + String(brightness));\r\n        }\r\n      }\r\n      if (server.hasArg(\"takeOwnership\")) {\r\n        setLEDControl((server.arg(\"ledValues\").c_str() == \"true\"));\r\n      }\r\n      if (server.hasArg(\"transition_time\")) {\r\n        float _transition_time = server.arg(\"transition_time\").toFloat();\r\n        numSteps = _transition_time * 16.6;\r\n        transition_interval = (unsigned long)(1000.0 * _transition_time / (float)numSteps);\r\n      }\r\n      if (server.hasArg(\"bankSelect\")) {\r\n        bankSelect = server.arg(\"bankSelect\").toInt(); \r\n      }\r\n\r\n      handleSetLeds(ledValues, bankSelect, (server.hasArg(\"transition_time\")));\r\n    }\r\n  });\r\n  server.on(\"/setLEDColor\", [=]() {\r\n    String ledValue = server.arg(\"ledColor\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Data Sent\");\r\n    if (pending_release_leds == false && currentPowerState0 != 1) {\r\n      int brightness = 64;\r\n      int bankSelect = 0;\r\n      brightness = server.arg(\"ledBrightness\").toInt();\r\n      if (server.hasArg(\"transition_time\")) {\r\n        float _transition_time = server.arg(\"transition_time\").toFloat();\r\n        numSteps = _transition_time * 16.6;\r\n        transition_interval = (unsigned long)(1000.0 * _transition_time / (float)numSteps);\r\n      }\r\n      if (server.hasArg(\"ledBrightness\")) {\r\n        if (brightness > 0 && brightness <= 255) {\r\n          if (server.hasArg(\"transition_time\")) {\r\n            targetBrightness = brightness;\r\n          } else {\r\n            FastLED.setBrightness(brightness);\r\n          }\r\n          Serial.println(\"Set brightness to: \" + String(brightness));\r\n        }\r\n      }\r\n      if (server.hasArg(\"bankSelect\")) {\r\n        bankSelect = server.arg(\"bankSelect\").toInt(); \r\n      }\r\n\r\n      handleSetLedColor(ledValue, bankSelect, (server.hasArg(\"transition_time\")));\r\n    }\r\n  });\r\n  server.on(\"/state\", [=]() {\r\n    server.send(200, \"text/plain\", (currentLEDState == 0)  ? \"MCU\" : \"GAME\");\r\n  });\r\n  server.on(\"/state/return\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Returned to owner\");\r\n    resetState();\r\n  });\r\n  server.on(\"/state/reset\", [=]() {\r\n    String ledValues = server.arg(\"ledValues\");  // Get the LED values from the URL parameter\r\n    server.sendHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n    server.sendHeader(\"Access-Control-Allow-Headers\", \"Content-Type X-Requested-With\");\r\n    server.sendHeader(\"Access-Control-Allow-Methods\", \"GET\");\r\n    server.sendHeader(\"Access-Control-Max-Age\", \"10000\");\r\n    server.send(200, \"text/plain\", \"LED Reset to standby\");\r\n    standbyLEDState();\r\n    \r\n  });\r\n\r\n  server.begin();\r\n\r\n  displayedSec = esp_timer_get_time() / 1000000;\r\n  \r\n  delay(250);\r\n  //bootScreen(\"SYS_PWR_ON\");\r\n  //setMasterPowerOn();\r\n  //delay(500);\r\n  bootScreen(\"TASK_PCLINK\");\r\n  xTaskCreatePinnedToCore(\r\n                  serialLoop,   /* Task function. */\r\n                  \"serialMonitor\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task3,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_CARDCOM\");\r\n  xTaskCreatePinnedToCore(\r\n                  cardReaderRXLoop,   /* Task function. */\r\n                  \"cardReaderRX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task4,      /* Task handle to keep track of created task */\r\n                  1);          /* pin task to core 1 */\r\n  delay(101);\r\n  xTaskCreatePinnedToCore(\r\n                  cardReaderTXLoop,   /* Task function. */\r\n                  \"cardReaderTX\",     /* name of task. */\r\n                  10000,       /* Stack size of task */\r\n                  NULL,        /* parameter of the task */\r\n                  1,           /* priority of the task */\r\n                  &Task5,      /* Task handle to keep track of created task */\r\n                  0);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_SOUND\");\r\n  xTaskCreatePinnedToCore(\r\n                    melodyPlayer,   /* Task function. */\r\n                    \"melodyTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    10,           /* priority of the task */\r\n                    &Task7,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  bootScreen(\"TASK_DISPLAY\");\r\n  xTaskCreatePinnedToCore(\r\n                    cpu0Loop,   /* Task function. */\r\n                    \"driverTask\",     /* name of task. */\r\n                    10000,       /* Stack size of task */\r\n                    NULL,        /* parameter of the task */\r\n                    10,           /* priority of the task */\r\n                    &Task1,      /* Task handle to keep track of created task */\r\n                    0);          /* pin task to core 1 */\r\n  delay(101);\r\n  melodyPlay = 2;\r\n  startMelody = true;\r\n}\r\n\r\nvoid loop() {\r\n  checkWiFiConnection();\r\n  server.handleClient();\r\n  unsigned long currentMillis = millis();\r\n  // Handle LED Handover\r\n  if (pending_release_leds == true && coinEnable == true) {\r\n    setLEDControl(false);\r\n    pending_release_leds = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n  } else if (pending_release_leds == false && coinEnable == false && currentPowerState0 == 1) {\r\n    startingLEDState();\r\n  }\r\n  // Handle Display Handover\r\n  displayMainState = (digitalRead(displayMainLDR) == LOW);\r\n  if (pending_release_display == true && coinEnable == true) {\r\n    pending_release_display = false;\r\n    kioskModeRequest(\"GameRunning\");\r\n    if (currentGameSelected0 < 2) {\r\n      delay(6000);\r\n      setDisplayState(false);\r\n    }\r\n  }\r\n  // Drive LED Animations\r\n  if (transition_leds == true) {\r\n    if (currentStep == 0) {\r\n      sourceBrightness = FastLED.getBrightness();\r\n      for (int i = 0; i < NUM_LEDS; i++) {\r\n        leds_source[i] = leds[i];\r\n      }\r\n    }\r\n    if (currentMillis - previousMillis >= transition_interval) {\r\n      previousMillis = currentMillis;\r\n      if (animation_mode == 2) {\r\n        numSteps = 3 * 33.2;\r\n        transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n        if (currentStep <= numSteps) {\r\n          FastLED.setBrightness(map(currentStep, 0, numSteps, sourceBrightness, targetBrightness));\r\n          for (int row = 0; row < 60; ++row) {\r\n            for (int col = 0; col < 8; ++col) {\r\n              int i = row * 8 + col;\r\n              int hue = currentStep + i * 4; /* 4 is the hue step between LEDs */\r\n              leds_target[i] = ColorFromPalette(currentPalette, hue, 255, currentBlendType);\r\n              leds[i].r = map(currentStep, 0, numSteps, leds_source[i].r, leds_target[i].r);\r\n              leds[i].g = map(currentStep, 0, numSteps, leds_source[i].g, leds_target[i].g);\r\n              leds[i].b = map(currentStep, 0, numSteps, leds_source[i].b, leds_target[i].b);\r\n            }\r\n          }\r\n        } else {\r\n          for (int row = 0; row < 60; ++row) {\r\n            for (int col = 0; col < 8; ++col) {\r\n              int i = row * 8 + col;\r\n              int hue = currentStep + i * 4; /* 4 is the hue step between LEDs */\r\n              leds[i] = ColorFromPalette(currentPalette, hue, 255, currentBlendType);\r\n            }\r\n          }\r\n        }\r\n        FastLED.show();\r\n        currentStep++;\r\n        animation_state = 1;\r\n      } else if (currentStep <= numSteps) {\r\n        FastLED.setBrightness(map(currentStep, 0, numSteps, sourceBrightness, targetBrightness));\r\n        for (int i = 0; i < NUM_LEDS; i++) {\r\n          leds[i].r = map(currentStep, 0, numSteps, leds_source[i].r, leds_target[i].r);\r\n          leds[i].g = map(currentStep, 0, numSteps, leds_source[i].g, leds_target[i].g);\r\n          leds[i].b = map(currentStep, 0, numSteps, leds_source[i].b, leds_target[i].b);\r\n        }\r\n        FastLED.show();\r\n        currentStep++;\r\n      } else if (animation_mode == 1) {\r\n        currentStep = 0;\r\n        if (animation_state == -1) {\r\n          for (int i = 0; i < NUM_LEDS; i++) {\r\n            leds_target[i] = CRGB::Black;\r\n          }\r\n          numSteps = 3 * 33.2;\r\n          transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n          animation_state = 1;\r\n        } else {\r\n          for (int i = 0; i < NUM_LEDS; i++) {\r\n            leds_target[i] = leds_source[i];\r\n          }\r\n          numSteps = 3 * 33.2;\r\n          transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n          animation_state = -1;\r\n        }\r\n      } else {\r\n        transition_leds = false;\r\n        animation_state = -1;\r\n        animation_mode = -1;\r\n        currentStep = 0;\r\n        //if (pending_release_leds == true) {\r\n        //  setLEDControl(false);\r\n        //}\r\n        pending_release_leds = false;\r\n        sourceBrightness = FastLED.getBrightness();\r\n        FastLED.show();\r\n      }\r\n    }\r\n  }\r\n  // Handle Shutdown Timer\r\n  if (currentPowerState0 == 1 && requestedPowerState0 > -1 && currentMillis - previousShutdownMillis >= (shutdownDelayMinTimeout * 60000)) {\r\n    if (requestedPowerState0 == 0) {\r\n      setMasterPowerOff();\r\n    } else if (requestedPowerState0 == 1) {\r\n      setGameOff();\r\n    }\r\n    requestedPowerState0 = -1;\r\n  } else if (currentPowerState0 == 0 && requestedPowerState0 > -1) {\r\n    if (requestedPowerState0 == 0) {\r\n      setMasterPowerOff();\r\n    }\r\n    requestedPowerState0 = -1;\r\n  }\r\n  // Handle Inactivity Timer\r\n  if (inactivityTimeout == true && currentPowerState0 == 1 && requestedPowerState0 == -1 && currentMillis - previousInactivityMillis >= (inactivityMinTimeout * 60000)) {\r\n    if (coinEnable == false) {\r\n      setGameOff();\r\n    } else if (coinEnable == true) {\r\n      shuttingDownLEDState(1);\r\n    }\r\n  }\r\n}\r\n\r\nvoid cpu0Loop( void * pvParameters ) {\r\n  for(;;) {\r\n    runtime();\r\n  }\r\n}\r\nvoid remoteAccessLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    delay(1);\r\n  }\r\n}\r\nvoid melodyPlayer( void * pvParameters ) {\r\n  for(;;) { \r\n    // Play Melody Sheets\r\n    if (startMelody == true) {\r\n      if (millis() - previousMelodyMillis >= pauseBetweenNotes) {\r\n        previousMelodyMillis = millis();\r\n        if (melodyPlay == 0) {\r\n          playMelody(booting_tone, booting_tone_dur, sizeof(booting_tone_dur) / sizeof(int));\r\n        } else if (melodyPlay == 1) {\r\n          playMelody(shutting_down_tone, shutting_down_dur, sizeof(shutting_down_dur) / sizeof(int));\r\n        } else if (melodyPlay == 2) {\r\n          playMelody(boot_tone, boot_tone_dur, sizeof(boot_tone_dur) / sizeof(int));\r\n        } else if (melodyPlay == 3) {\r\n          const float position = ((millis() - previousShutdownMillis) / 60000);\r\n          int val = map(position, 0, 4, loopMelody, 0) * 1000;\r\n          if (val <= 1) {\r\n            playMelody(warning_tone_long, warning_tone_long_dur, sizeof(warning_tone_long_dur) / sizeof(int));\r\n          } else {\r\n            playMelody(warning_tone, warning_tone_dur, sizeof(warning_tone_dur) / sizeof(int));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}\r\nvoid pingLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    delay(1000);\r\n    Serial.println(\"\");\r\n    Serial.println(\"PROBE::SEARCH\");\r\n    Serial.println(\"\");\r\n  }\r\n}\r\nvoid serialLoop( void * pvParameters ) {\r\n  kioskCommand();\r\n}\r\nvoid cardReaderTXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (typeOfMessage != -1) {\r\n      // DISPLAY_MESSAGE::BIG::icon::text::isJP/t::255::invert/t::timeout/20\r\n      cardReaderSerial.print(\"DISPLAY_MESSAGE::\");\r\n      cardReaderSerial.print((typeOfMessage == 1) ? \"BIG\" : \"SMALL\");\r\n      typeOfMessage = -1;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(String(messageIcon));\r\n      messageIcon = 0;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(messageText);\r\n      messageText = \"\";\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print((isJpnMessage == true) ? \"t\" : \"f\");\r\n      isJpnMessage = false;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print(String(brightMessage));\r\n      brightMessage = 1;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.print((invertMessage == true) ? \"t\" : \"f\");\r\n      invertMessage = false;\r\n      cardReaderSerial.print(\"::\");\r\n      cardReaderSerial.println(String(timeoutMessage));\r\n      timeoutMessage = 0;\r\n    }\r\n    int value = 0;\r\n    if (currentPowerState0 == -1 || (currentPowerState0 == 1 && requestedPowerState0 != -1)) {\r\n      value = 0;\r\n    } else if (currentPowerState0 == 0) {\r\n      value = 1;\r\n    } else if (currentPowerState0 == 1 && requestedPowerState0 == -1) {\r\n      value = 2;\r\n    }\r\n    cardReaderSerial.println(\"POWER_SWITCH::\" + String(value));\r\n    delay(100);\r\n  }\r\n}\r\nvoid cardReaderRXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (cardReaderSerial.available()) {\r\n      static String receivedMessage = \"\";\r\n      char c;\r\n      bool messageStarted = false;\r\n\r\n      while (cardReaderSerial.available()) {\r\n        c = cardReaderSerial.read();\r\n        if (c == '\\n') {\r\n          if (!receivedMessage.isEmpty()) {\r\n            handleCRMessage(receivedMessage);\r\n            //Serial.println(\"Received: \" + receivedMessage);\r\n          }\r\n          receivedMessage = \"\";\r\n        } else {\r\n          receivedMessage += c;\r\n        }\r\n\r\n      }\r\n    } else {\r\n      delay(1);\r\n    }\r\n  }\r\n}\r\nvoid nuControlRXLoop( void * pvParameters ) {\r\n  for(;;) {\r\n    if (nuControl.available()) {\r\n      static String receivedMessage = \"\";\r\n      char c;\r\n      bool messageStarted = false;\r\n\r\n      while (nuControl.available()) {\r\n        c = nuControl.read();\r\n        if (c == '\\n') {\r\n          if (!receivedMessage.isEmpty()) {\r\n            int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n            if (delimiterIndex != -1) {\r\n              int headerIndex = receivedMessage.indexOf(\"::\");\r\n              String header = receivedMessage.substring(0, headerIndex);\r\n              if (header == \"PS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 2) {\r\n                  currentNuPowerState0 = valueInt;\r\n                }\r\n              } else if (header == \"BS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 2) {\r\n                  currentNuBoardState0 = valueInt;\r\n                }\r\n              } else if (header == \"DS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 9 && inhibitNuState == false) {\r\n                  currentGameSelected0 = valueInt;\r\n                }\r\n              } else if (header == \"NS\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 9 && inhibitNuState == false) {\r\n                  currentALLSLANMode0 = valueInt;\r\n                }\r\n              } else if (header == \"R\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String _nuResponse = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                _nuResponse.trim();\r\n                nuResponse = _nuResponse;\r\n                Serial.println(\"NU_CTRL::\" + nuResponse);\r\n              } else if (header == \"DBG\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n                String _nuResponse = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n                _nuResponse.trim();\r\n                Serial.println(\"NU_CTRL_DEBUGGER::\" + _nuResponse);\r\n              }\r\n            }\r\n          }\r\n          receivedMessage = \"\";\r\n        } else {\r\n          receivedMessage += c;\r\n        }\r\n\r\n      }\r\n    } else {\r\n      delay(1);\r\n    }\r\n  }\r\n}\r\n\r\nvoid runtime() {\r\n  int time_in_sec = esp_timer_get_time() / 1000000;\r\n  unsigned long currentMillis = millis();\r\n  int current_time = (time_in_sec - displayedSec) / 2;\r\n\r\n  if (displayState != 1 && currentPowerState0 == -1) {\r\n    const String power = getPowerAuth();\r\n    displayIconDualMessage(1, false, false, (power == \"Active\") ? 491 : 490, \"System Power\", power);\r\n    displayState = 1;\r\n  } else if (currentPowerState0 == -1) {\r\n    delay(500);\r\n  } else if (currentPowerState0 != -1) {\r\n    if (displayState != 0 && current_time < 1) {\r\n      displayIconMessage(1, true, true, 250, \"ワッカ\");\r\n      displayState = 0;\r\n    } else if (displayState != 1 && current_time >= 1 && current_time < 2) {\r\n      const String power = getPowerAuth();\r\n      displayIconDualMessage(1, (power == \"Active\"), false, (power == \"Active\") ? 491 : 490, \"System Power\", power);\r\n      displayState = 1;\r\n    } else if (displayState != 2 && current_time >= 2 && current_time < 3) {\r\n      String timeout = \"\";\r\n      if (requestedPowerState0 != -1) {\r\n        timeout = \"Expired\";\r\n      } else if (currentPowerState0 == 1 && inactivityTimeout == true) {\r\n        timeout = String(inactivityMinTimeout - ((millis() - previousInactivityMillis) / 60000));\r\n        timeout += \" Min\";\r\n      } else {\r\n        timeout = \"Disabled\";\r\n      }\r\n      displayIconDualMessage(1, ((currentPowerState0 == 1 && inactivityTimeout == true && (((millis() - previousInactivityMillis) / 60000) < (inactivityMinTimeout - 5))) ? true : false), false, 459, \"Timeout\", timeout);\r\n      displayState = 2;\r\n    } else if (displayState != 3 && current_time >= 3 && current_time < 4) {\r\n      String volume = \"\";\r\n      if (muteVolume == false) {\r\n        volume += map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n        volume += \"%\";\r\n      } else {\r\n        volume = \"Muted\";\r\n      }\r\n      displayIconDualMessage(1, (currentVolume >= 50 || muteVolume == true), false, 578, \"Speakers\", volume.c_str());\r\n      displayState = 3;\r\n    } else if (displayState != 4 && current_time >= 4 && current_time < 5) {\r\n      String fan = \"\";\r\n      fan += map(currentFan1Speed, 0, 255, 0, 100);\r\n      fan += \"% / \";\r\n      fan += map(currentFan2Speed, 0, 255, 0, 100);\r\n      fan += \"%\";\r\n      displayIconDualMessage(1, (map(currentFan1Speed, 0, 255, 0, 100) >= 75 || map(currentFan2Speed, 0, 255, 0, 100) >= 75), false, 225, \"Fans\", fan.c_str());\r\n      displayState = 4;\r\n    } else if (displayState != 5 && current_time >= 5 && current_time < 6) {\r\n      displayIconDualMessage(1, (currentMarqueeState == 1), false, 398, \"Marquee\", (currentMarqueeState == 1) ? \"Enabled\" : \"Disabled\");\r\n      displayState = 5;\r\n    } else if (displayState != 6 && current_time >= 6 && current_time < 7) {\r\n      displayIconDualMessage(1, (displayMainState == false), false, (displayMainState == false) ? 250 : 129, \"Display Source\", (displayMainState == true) ? \"PC\" : \"Game\");\r\n      displayState = 6;\r\n    } else if (displayState != 7 && current_time >= 7 && current_time < 8) {\r\n      displayIconDualMessage(1, (currentLEDState == 1), false, 398, \"LED Control\", (currentLEDState == 0) ? \"MCU\" : \"Game\");\r\n      displayState = 7;\r\n    } else if (displayState != 8 && current_time >= 8 && current_time < 9) {\r\n      displayIconDualMessage(1, false, false, 141, \"Game Disk\", getGameSelect());\r\n      displayState = 8;\r\n    } else if (displayState != 9 && current_time >= 9 && current_time < 10) {\r\n      displayIconDualMessage(1, (currentALLSLANMode0 == 0), false, 109, \"ALLS Ethernet\", ((currentALLSLANMode0 == 0) ? \"VPN\" : \"LAN\"));\r\n      displayState = 9;\r\n    } else if (displayState != 10 && current_time >= 10 && current_time < 11) {\r\n      displayIconDualMessage(1, (coinEnable == true), false, 71, \"Card Reader\", (has_cr_talked == false) ? \"No Data\" : (coinEnable == true) ? \"Enabled\" : \"Disabled\");\r\n      displayState = 10;\r\n    } else if (current_time >= 11) {\r\n      displayedSec = time_in_sec;\r\n    }\r\n  }\r\n}\r\n\r\nvoid bootScreen(String input_message) {\r\n  u8g2.clearBuffer();\r\n  u8g2.setFont(u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  const char* string = input_message.c_str();\r\n  int textWidth = u8g2.getStrWidth(string);\r\n  int centerX = ((u8g2.getWidth() - textWidth) / 2);\r\n  int centerGlX = ((u8g2.getWidth() - textWidth) / 2);\r\n  int centerY = u8g2.getHeight() / 2 + u8g2.getAscent() / 2;\r\n  u8g2.drawStr(centerX, centerY, string);\r\n  u8g2.sendBuffer();\r\n}\r\nvoid playMelody(int tones[], int durations[], int size) {\r\n  if (currentNote < size) {\r\n    int noteDuration = 1000 / durations[currentNote];\r\n    tone(buzzer_pin, tones[currentNote], noteDuration);\r\n    pauseBetweenNotes = noteDuration * 1.30;\r\n    currentNote++;\r\n  } else {\r\n    // Melody is finished\r\n    currentNote = 0;\r\n    if (loopMelody != -1) {\r\n      if (melodyPlay == 3) {\r\n        const float position = ((millis() - previousShutdownMillis) / 60000);\r\n        pauseBetweenNotes = map(position, 0, 4, loopMelody, 0) * 1000;\r\n      } else {\r\n        pauseBetweenNotes = loopMelody * 1000;\r\n      }\r\n    } else {\r\n      startMelody = false;\r\n      melodyPlay = -1;\r\n    }\r\n  }\r\n}\r\nvoid displayIconMessage(int bright, bool invert, bool jpn, int icon, String input_message) {\r\n  u8g2.setPowerSave(0);\r\n  u8g2.setContrast(bright);\r\n  u8g2.clearBuffer();\r\n  int Xpos = 2;\r\n  const char* string = input_message.c_str();\r\n  if (invert == true) {\r\n    u8g2.setDrawColor(1);\r\n    u8g2.drawBox(0, 0, u8g2.getWidth(), u8g2.getHeight());\r\n    u8g2.sendBuffer();\r\n    u8g2.setDrawColor(0);\r\n    u8g2.setColorIndex(0);\r\n  }\r\n  u8g2.setFont((jpn == true) ? u8g2_font_b12_t_japanese1 : u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  int textWidth = u8g2.getUTF8Width(string);\r\n  int centerX = Xpos + 28;\r\n  int centerY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawUTF8(centerX, centerY, string);\r\n  u8g2.setFont(u8g2_font_streamline_all_t);\r\n  int centerGlX = Xpos;\r\n  int centerGlY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawGlyph(centerGlX, centerGlY, icon);\r\n  u8g2.setDrawColor(1);\r\n  u8g2.sendBuffer();\r\n}\r\nvoid displayIconDualMessage(int bright, bool invert, bool jpn, int icon, String input_message, String input2_message) {\r\n  u8g2.setPowerSave(0);\r\n  u8g2.setContrast(bright);\r\n  u8g2.clearBuffer();\r\n  int Xpos = 2;\r\n  const char* string = input_message.c_str();\r\n  const char* string2 = input2_message.c_str();\r\n  if (invert == true) {\r\n    u8g2.setDrawColor(1);\r\n    u8g2.drawBox(0, 0, u8g2.getWidth(), u8g2.getHeight());\r\n    u8g2.sendBuffer();\r\n    u8g2.setDrawColor(0);\r\n    u8g2.setColorIndex(0);\r\n  }\r\n  u8g2.setFont((jpn == true) ? u8g2_font_b12_t_japanese1 : u8g2_font_HelvetiPixel_tr);  // Choose your font\r\n  int textWidth = u8g2.getUTF8Width(string);\r\n  int centerX = Xpos + 28;\r\n  int centerY = ((u8g2.getHeight() / 2 + u8g2.getAscent() / 2) / 2) + 2;\r\n  int centerY2 = (centerY * 2) + 3;\r\n  u8g2.drawUTF8(centerX, centerY, string);\r\n  u8g2.drawUTF8(centerX, centerY2, string2);\r\n  u8g2.setFont(u8g2_font_streamline_all_t);\r\n  int centerGlX = Xpos;\r\n  int centerGlY = (u8g2.getHeight() / 2 + u8g2.getAscent() / 2);\r\n  u8g2.drawGlyph(centerGlX, centerGlY, icon);\r\n  u8g2.setDrawColor(1);\r\n  u8g2.sendBuffer();\r\n}\r\n\r\nString getGameSelect() {\r\n  String assembledOutput = \"\";\r\n  switch (requestedGameSelected0) {\r\n    case -1:\r\n      assembledOutput = \"No Data\";\r\n      break;\r\n    case 0:\r\n      assembledOutput = \"Reverse\";\r\n      break;\r\n    case 1:\r\n      assembledOutput = \"Lilly\";\r\n      break;\r\n    default:\r\n      assembledOutput = \"Other\";\r\n      break;\r\n  }\r\n  if (enhancedStandby == true) {\r\n    assembledOutput += \"*\";\r\n  }\r\n  return assembledOutput;\r\n}\r\nString getPowerAuth() {\r\n  String assembledOutput = \"\";\r\n  assembledOutput += ((requestedPowerState0 != -1) ? \"Warning\" : ((currentPowerState0 == -1) ? ((enhancedStandby == true) ? \"Power Off (E)\" : \"Power Off\") : (currentPowerState0 == 0) ? ((enhancedStandby == true) ? \"Standby (E)\" : \"Standby\") : (coinEnable == false) ? \"Startup\" : \"Active\"));\r\n  return assembledOutput;\r\n}\r\nvoid displayVolumeMessage() {\r\n  int curVol = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n  if (muteVolume == true) {\r\n    messageIcon = 279;\r\n    messageText = \"Volume Muted\";\r\n    invertMessage = true;\r\n  } else {\r\n    messageIcon = 277;\r\n    messageText = \"Volume: \";\r\n    messageText += String(curVol);\r\n    messageText += \"%\";\r\n    invertMessage = (curVol >= 40);\r\n  }\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  timeoutMessage = 10;\r\n  typeOfMessage = 1;\r\n}\r\n\r\nvoid defaultLEDState() {\r\n  FastLED.setBrightness(0);\r\n  for (int i = 0; i < NUM_LEDS; i++) {\r\n    leds[i] = CRGB::Black;\r\n  }\r\n  FastLED.show();\r\n  delay(50);\r\n  FastLED.show();\r\n}\r\nvoid standbyLEDState() {\r\n  FastLED.setBrightness(64);\r\n  int hue = 37;\r\n  int rowCount = 7;\r\n  for (int i = 0; i < NUM_LEDS; i++) {\r\n    leds[i] = CHSV(map(hue, 0,360,0,255), 255, 255 - (rowCount * 10));\r\n    rowCount--;\r\n    if (rowCount <= -1) {\r\n      rowCount = 7;\r\n    }\r\n  }\r\n  FastLED.show();\r\n  delay(50);\r\n  FastLED.show();\r\n}\r\nvoid startingLEDState() {\r\n  setLEDControl(true);\r\n  targetBrightness = 255;\r\n  numSteps = 4.0 * 33.2;\r\n  transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n  // int hue = 120;\r\n  // int rowCount = 7;\r\n  // for (int i = 0; i < NUM_LEDS; i++) {\r\n  //   CHSV in = CHSV(map(hue, 0,360,0,255), 255, 255 - (map((rowCount * 10), 0, 100, 0, 255)));\r\n  //   CRGB out;\r\n  //   hsv2rgb_rainbow(in, out);\r\n  //   leds_target[i] = out;\r\n  //   rowCount--;\r\n  //   if (rowCount <= -1) {\r\n  //     rowCount = 7;\r\n  //   }\r\n  // }\r\n  pending_release_leds = true;\r\n  animation_state = -1;\r\n  // animation_mode = 1;\r\n  animation_mode = 2;\r\n  currentStep = 0;\r\n  currentPalette = RainbowColors_p;\r\n  transition_leds = true;\r\n}\r\nvoid shuttingDownLEDState(int state) {\r\n  kioskModeRequest(\"WarningGame\");\r\n  setLEDControl(true);\r\n  targetBrightness = 255;\r\n  numSteps = 4.0 * 33.2;\r\n  transition_interval = (unsigned long)(1000.0 * 4.0 / (float)numSteps);\r\n  int hue = 0;\r\n  int rowCount = 7;\r\n  for (int i = 0; i < NUM_LEDS; i++) {\r\n    CHSV in = CHSV(map(hue, 0,360,0,255), 255, 255 - (map((rowCount * 10), 0, 100, 0, 255)));\r\n    CRGB out;\r\n    hsv2rgb_rainbow(in, out);\r\n    leds_target[i] = out;\r\n    rowCount--;\r\n    if (rowCount <= -1) {\r\n      rowCount = 7;\r\n    }\r\n  }\r\n  previousShutdownMillis = millis();\r\n  requestedPowerState0 = state;\r\n  pending_release_leds = false;\r\n  animation_state = -1;\r\n  animation_mode = 1;\r\n  currentStep = 0;\r\n  transition_leds = true;\r\n\r\n  melodyPlay = 3;\r\n  loopMelody = 2;\r\n  currentNote = 0;\r\n  previousMelodyMillis = 0;\r\n  startMelody = true;\r\n\r\n  messageIcon = (requestedPowerState0 == -1) ? 96 : 223;\r\n  messageText = (requestedPowerState0 == -1) ? \"Power Off\" : \"Standby\";\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  invertMessage = true;\r\n  timeoutMessage = 25;\r\n  typeOfMessage = 1;\r\n}\r\nvoid startLoadingScreen() {\r\n  pending_release_display = true;\r\n  kioskModeRequest(\"StartGame\");\r\n}\r\n\r\nvoid handleSetLeds(String ledValues, int bankSelect, bool should_transition) {\r\n  Serial.println(\"Received LED values: \" + ledValues);\r\n  int index = 0;\r\n  while (ledValues.length() > 0 && index < NUM_LEDS) {\r\n    String hexValue = ledValues.substring(0, ledValues.indexOf(' '));\r\n    ledValues = ledValues.substring(ledValues.indexOf(' ') + 1);\r\n    uint32_t color = (uint32_t)strtol(hexValue.c_str(), NULL, 16);\r\n\r\n    if (index < NUM_LEDS) {\r\n      if (bankSelect == 0) {\r\n        if (should_transition == true) {\r\n          leds_target[index] = color;\r\n        } else {\r\n          leds[index] = color;\r\n        }\r\n      }\r\n    } else {\r\n      Serial.println(\"Received LED Value Index OUT OF RANGE OF CONTROLLER: \" + index);\r\n    }\r\n    index++;\r\n  }\r\n  if (should_transition == true) {\r\n    bool all_same = true;\r\n    for (int i = 0; i < NUM_LEDS; i++) {\r\n      if (leds_source[i].r != leds_target[i].r && leds_source[i].g != leds_target[i].g && leds_source[i].b != leds_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (all_same == false) {\r\n      transition_leds = true;\r\n    } else {\r\n      FastLED.show();\r\n      delay(33);\r\n      FastLED.show();\r\n    }\r\n  } else {\r\n    FastLED.show();\r\n    delay(33);\r\n    FastLED.show();\r\n  }\r\n}\r\nvoid handleSetLedColor(String ledValue, int bankSelect, bool should_transition) {\r\n  Serial.println(\"Received LED value: \" + ledValue);\r\n  uint32_t color = (uint32_t)strtol(ledValue.c_str(), NULL, 16);\r\n  int index = 0;\r\n\r\n  if (bankSelect == 0) {\r\n    for (int i = 0; i < NUM_LEDS; i++) {\r\n      if (should_transition == true) {\r\n        leds_target[i] = color;\r\n      } else {\r\n        leds[i] = color;\r\n      }\r\n    }\r\n  }\r\n  if (should_transition == true) {\r\n    bool all_same = true;\r\n    for (int i = 0; i < NUM_LEDS; i++) {\r\n      if (leds_source[i].r != leds_target[i].r && leds_source[i].g != leds_target[i].g && leds_source[i].b != leds_target[i].b) {\r\n        all_same = false;\r\n      }\r\n    }\r\n    if (all_same == false) {\r\n      transition_leds = true;\r\n    } else {\r\n      FastLED.show();\r\n      delay(33);\r\n      FastLED.show();\r\n    }\r\n  } else {\r\n    FastLED.show();\r\n    delay(133);\r\n    FastLED.show();\r\n  }\r\n}\r\nbool ignore_next_state = false;\r\nvoid handleCRMessage(String inputString) {\r\n  int delimiterIndex = inputString.indexOf(\"::\");\r\n  if (delimiterIndex != -1) {\r\n    int headerIndex = inputString.indexOf(\"::\");\r\n    String header = inputString.substring(0, headerIndex);\r\n    if (header == \"COIN_ENABLE\") {\r\n      has_cr_talked = true;\r\n      ignore_next_state = false;\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      int responseCode = valueString.toInt();\r\n      switch (responseCode) {\r\n        case 0:\r\n          coinEnable = false;\r\n          break;\r\n        case 1:\r\n          coinEnable = true;\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else if (header == \"COIN_DISPENSE\") {\r\n      has_cr_talked = true;\r\n      int valueIndex = inputString.indexOf(\"::\", headerIndex + 2);\r\n      String valueString = inputString.substring(headerIndex + 2, valueIndex);\r\n      int responseCode = valueString.toInt();\r\n      int dataIndex = inputString.indexOf(\"::\", valueIndex + 2);\r\n      String dataString = inputString.substring(valueIndex + 2, dataIndex);\r\n\r\n      Serial.println(valueString);\r\n      Serial.println(dataString);\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        if (responseCode >= 200 && responseCode < 300) {\r\n          resetInactivityTimer();\r\n        } else if (valueString == \"FALSE\") {\r\n        }\r\n      }\r\n    } else if (header == \"BOOT_REQUEST\") {\r\n      has_cr_talked = true;\r\n      if (ignore_next_state == false) {\r\n        ignore_next_state = true;\r\n        setGameOn();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid setMasterPowerOn() {\r\n  if (currentPowerState0 == -1) {\r\n    setIOPower(true);\r\n    delay(250);\r\n    setLEDControl(true);\r\n    kioskModeRequest(\"StartStandby\");\r\n    resetMarqueeState();\r\n    setChassisFanSpeed(35);\r\n    setMainFanSpeed((enhancedStandby == true) ? 100 : 25);\r\n    delay(500);\r\n    defaultLEDState();\r\n    standbyLEDState();\r\n    setDisplayState(true);\r\n    if (enhancedStandby == true) {\r\n      enterEnhancedStandby(true);\r\n    } else {\r\n      setSysBoardPower(false);\r\n    }\r\n    currentPowerState0 = 0;\r\n\r\n    pending_release_leds = false;\r\n    pending_release_display = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n    \r\n    messageIcon = 223;\r\n    messageText = (enhancedStandby == true) ? \"E. Standby Mode\" : \"Standby Mode\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  requestedPowerState0 = -1;\r\n}\r\nvoid setMasterPowerOff() {\r\n  kioskModeRequest(\"StopAll\");\r\n  setChassisFanSpeed(0);\r\n  setMainFanSpeed((enhancedStandby == true) ? 75 : 15);\r\n  setLEDControl(true);\r\n  setMarqueeState(false, false);\r\n  if (currentPowerState0 == 1) {\r\n    if (enhancedStandby == true) {\r\n      enterEnhancedStandby(true);\r\n    } else {\r\n      delay(500);\r\n      setSysBoardPower(false);\r\n      delay(200);\r\n    }\r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n  } else {\r\n    melodyPlay = -1;\r\n    loopMelody = -1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = false;\r\n  }\r\n  delay(500);\r\n  setIOPower(false);\r\n  setDisplayState(false);\r\n  if (currentPowerState0 != -1) {\r\n    messageIcon = 96;\r\n    messageText = \"Power Off\";\r\n    isJpnMessage = false;\r\n    brightMessage = 1;\r\n    invertMessage = true;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  requestedPowerState0 = -1;\r\n  currentPowerState0 = -1;\r\n}\r\nvoid setGameOn() {\r\n  if (currentPowerState0 == -1) {\r\n    setIOPower(true);\r\n    delay(1000);\r\n  }\r\n  if (currentPowerState0 != 1) {\r\n    inactivityMinTimeout = defaultInactivityMinTimeout + 5;\r\n    previousInactivityMillis = millis();\r\n    startLoadingScreen();\r\n    setChassisFanSpeed(75);\r\n    setMainFanSpeed(100);\r\n    startingLEDState();\r\n    setMarqueeState(true, false);\r\n    if (enhancedStandby == true) {\r\n      exitEnhancedStandby();\r\n    }\r\n    if (requestedGameSelected0 != currentGameSelected0) {\r\n      setGameDisk(requestedGameSelected0);\r\n    }\r\n    setDisplayState(true);\r\n    setSysBoardPower(true);\r\n    \r\n    melodyPlay = 0;\r\n    loopMelody = -1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n    \r\n    pending_release_display = true;\r\n    \r\n    messageIcon = 96;\r\n    messageText = \"Power On\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = true;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  if (requestedPowerState0 != -1) {\r\n    resetState();\r\n  }\r\n  requestedPowerState0 = -1;\r\n  currentPowerState0 = 1;\r\n}\r\nvoid setGameOff() {\r\n  if (currentPowerState0 == 1) {\r\n    currentPowerState0 = 0;\r\n\r\n    pending_release_leds = false;\r\n    pending_release_display = false;\r\n    transition_leds = false;\r\n    animation_state = -1;\r\n    animation_mode = -1;\r\n    currentStep = 0;\r\n\r\n    setDisplayState(true);\r\n    setChassisFanSpeed(35);\r\n    setMainFanSpeed((enhancedStandby == true) ? 100 : 25);\r\n    kioskModeRequest(\"StartStandby\");\r\n    setLEDControl(true);\r\n    delay(250);\r\n    standbyLEDState();\r\n    resetMarqueeState();\r\n    if (enhancedStandby == true) {\r\n      enterEnhancedStandby(true);\r\n    } else {\r\n      setSysBoardPower(false);\r\n    }\r\n    \r\n    loopMelody = -1;\r\n    melodyPlay = 1;\r\n    currentNote = 0;\r\n    previousMelodyMillis = 0;\r\n    startMelody = true;\r\n    \r\n    messageIcon = 223;\r\n    messageText = \"Standby Mode\";\r\n    isJpnMessage = false;\r\n    brightMessage = 255;\r\n    invertMessage = false;\r\n    timeoutMessage = 10;\r\n    typeOfMessage = 1;\r\n  }\r\n  currentPowerState0 = 0;\r\n  requestedPowerState0 = -1;\r\n}\r\nvoid requestPowerOff() {\r\n  if (currentPowerState0 == 1 && coinEnable == false) {\r\n    setMasterPowerOff();\r\n  } else if (currentPowerState0 == 1 && coinEnable == true) {\r\n    shuttingDownLEDState(0);\r\n  } else if (currentPowerState0 == 0) {\r\n    setMasterPowerOff();\r\n  }\r\n}\r\nvoid requestStandby() {\r\n  if (currentPowerState0 == 1) {\r\n    setGameOff();\r\n  } else {\r\n    setMasterPowerOn();\r\n  }\r\n}\r\n\r\nvoid enterEnhancedStandby(bool state) {\r\n  inhibitNuState = false;\r\n  if (state == true) {\r\n    digitalWrite(relayPins[3], HIGH);\r\n    digitalWrite(relayPins[4], LOW);\r\n    nuResponse = \"\";\r\n    int i = 0;\r\n    while (currentGameSelected0 != 2 && i < 10) {\r\n      nuControl.println(\"DS::2\");\r\n      delay(125);\r\n      i++;\r\n    }\r\n    i = 0;\r\n    if (currentNuPowerState0 == 0) {\r\n      nuResponse = \"\";\r\n      while (currentNuPowerState0 == 0 && i < 10) {\r\n        nuControl.println(\"PS::1::\");\r\n        delay(125);\r\n        i++;\r\n      }\r\n    }\r\n  } else if (state == false) {\r\n    if (currentNuPowerState0 == 1) {\r\n      exitEnhancedStandby();\r\n      int i = 0;\r\n      nuResponse = \"\";\r\n      while (currentNuPowerState0 == 1 && i < 10) {\r\n        nuControl.println(\"PS::0::\");\r\n        delay(125);\r\n        i++;\r\n      }\r\n    }\r\n    digitalWrite(relayPins[3], LOW);\r\n    digitalWrite(relayPins[4], LOW);\r\n  }\r\n}\r\nvoid exitEnhancedStandby() {\r\n  tone(buzzer_pin, NOTE_D4);\r\n  HTTPClient http;\r\n  String url = String(shutdown_url);\r\n  Serial.println(\"Sending GET request to: \" + url);\r\n  http.begin(url);\r\n  http.setConnectTimeout(5000);\r\n  http.setTimeout(120000); // Wait 120 Sec for complete Shutdown\r\n  int httpCode = http.GET();\r\n  String payload = http.getString();\r\n  Serial.println(payload);\r\n  http.end();\r\n  Serial.println(\"HTTP Response code: \" + String(httpCode));\r\n  noTone(buzzer_pin);\r\n  delay(5);\r\n}\r\nvoid setSysBoardPower(bool state) {\r\n  nuResponse = \"\";\r\n  digitalWrite(relayPins[3], (state == true) ? HIGH : LOW);\r\n  while (currentNuPowerState0 == ((state == true) ? 0 : 1)) {\r\n    nuControl.print(\"PS::\");\r\n    nuControl.println(((state == true) ? \"1\" : \"0\"));\r\n    delay(100);\r\n  }\r\n  digitalWrite(relayPins[4], (currentGameSelected0 < 2) ? ((state == true) ? HIGH : LOW) : LOW);\r\n  delay((state == true) ? 200 : 500);\r\n}\r\nvoid setLEDControl(bool state) {\r\n  digitalWrite(relayPins[1], (state == true) ? LOW : HIGH);\r\n  int last_state = currentLEDState;\r\n  currentLEDState = (state == true) ? 0 : 1;\r\n  if (last_state == false && state == true) {\r\n    delay(500);\r\n  }\r\n}\r\nvoid setIOPower(bool state) {\r\n  digitalWrite(relayPins[0], (state == true) ? HIGH : LOW);\r\n  delay(750);\r\n  digitalWrite(relayPins[2], (state == true) ? HIGH : LOW);\r\n}\r\nvoid resetPSU() {\r\n  digitalWrite(relayPins[4], LOW);\r\n  delay(2000);\r\n  digitalWrite(relayPins[4], HIGH);\r\n}\r\nvoid resetMarqueeState() {\r\n  digitalWrite(relayPins[5], (currentMarqueeState == 1) ? HIGH : LOW);\r\n}\r\nvoid setMarqueeState(bool state, bool save) {\r\n  if (currentPowerState0 != -1) {\r\n    digitalWrite(relayPins[5], (state == true) ? HIGH : LOW);\r\n  }\r\n  if (save == true) {\r\n    currentMarqueeState = (state == true) ? 1 : 0;\r\n  }\r\n}\r\nvoid setChassisFanSpeed(int speed) {\r\n  currentFan1Speed = map(speed, 0, 100, 0, 255);\r\n  analogWrite(fanPWM1, currentFan1Speed);\r\n}\r\nvoid setMainFanSpeed(int speed) {\r\n  currentFan2Speed = map(speed, 0, 100, 0, 255);\r\n  analogWrite(fanPWM2, currentFan2Speed);\r\n}\r\nvoid setGameDisk(int number) {\r\n  inhibitNuState = false;\r\n  nuResponse = \"\";\r\n  while (currentGameSelected0 != number) {\r\n    nuControl.print(\"DS::\");\r\n    nuControl.println(String(number));\r\n    delay(100);\r\n  }\r\n  if (currentPowerState0 == 1) {\r\n      setSysBoardPower(true);\r\n      setDisplayState(false);\r\n    if (number < 2) {\r\n      resetPSU();\r\n      startingLEDState();\r\n      //startLoadingScreen();\r\n    }\r\n  }\r\n  messageIcon = 129;\r\n  messageText = \"HDD: \";\r\n  switch (number) {\r\n    case 0:\r\n      messageText += \"Reverse\";\r\n      break;\r\n    case 1:\r\n      messageText += \"Lilly\";\r\n      break;\r\n    case 2:\r\n      messageText += \"Enhanced STB\";\r\n      break;\r\n    default:\r\n      messageText += \"???\";\r\n      break;\r\n  }\r\n  invertMessage = (currentPowerState0 == 1);\r\n  isJpnMessage = false;\r\n  brightMessage = 255;\r\n  timeoutMessage = 10;\r\n  typeOfMessage = 1;\r\n}\r\nvoid setDisplayState(bool state) {\r\n  if (state != displayMainState) {\r\n    pushDisplaySwitch();\r\n  }\r\n}\r\nvoid resetState() {\r\n  setLEDControl((currentPowerState0 != 1));\r\n  if (currentLEDState == 0) {\r\n    delay(800);\r\n    setLEDControl(false);\r\n  }\r\n  setDisplayState((currentGameSelected0 >= 2 || currentPowerState0 != 1));\r\n  kioskModeRequest(\"ResetState\");\r\n  startMelody = false;\r\n  melodyPlay = -1;\r\n  loopMelody = -1;\r\n  currentNote = 0;\r\n  previousMelodyMillis = 0;\r\n\r\n  pending_release_leds = false;\r\n  pending_release_display = false;\r\n  animation_state = -1;\r\n  animation_mode = -1;\r\n  currentStep = 0;\r\n  requestedPowerState0 = -1;\r\n  previousInactivityMillis = millis();\r\n  inactivityMinTimeout = defaultInactivityMinTimeout;\r\n}\r\nvoid resetInactivityTimer() {\r\n  resetState();\r\n  previousInactivityMillis = millis();\r\n  inactivityMinTimeout = defaultInactivityMinTimeout + 20;\r\n}\r\n\r\nvoid pushDisplaySwitch() {\r\n  digitalWrite(displayMainSelect, HIGH);\r\n  digitalWrite(displayMainSelect, LOW);\r\n  delay(500);\r\n  digitalWrite(displayMainSelect, HIGH);\r\n}\r\n\r\nvoid kioskModeRequest(String command) {\r\n  Serial.println(\"\");\r\n  Serial.println(\"ACTION::\" + command);\r\n  Serial.println(\"\");\r\n}\r\nvoid kioskTest() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool messageStarted = false;\r\n\r\n\r\n  while (ready_to_boot == false) {\r\n    while (Serial.available()) {\r\n      c = Serial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"PROBE\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"HELLO\") {\r\n                int softwareIndex = receivedMessage.indexOf(\"::\", valueIndex + 2);\r\n                attachedSoftwareCU = receivedMessage.substring(valueIndex + 2, softwareIndex);\r\n                ready_to_boot = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n  if(Task3 != NULL) {\r\n    vTaskDelete(Task3);\r\n  }\r\n}\r\nvoid testCardReader() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool card_reader_txrx_ok = false;\r\n\r\n\r\n  while (card_reader_txrx_ok == false) {\r\n    while (cardReaderSerial.available()) {\r\n      c = cardReaderSerial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"HELLO\") {\r\n              card_reader_txrx_ok = true;\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}\r\nvoid kioskCommand() {\r\n  static String receivedMessage = \"\";\r\n  char c;\r\n  bool messageStarted = false;\r\n\r\n  for(;;) {\r\n    while (Serial.available()) {\r\n      c = Serial.read();\r\n      if (c == '\\n') {\r\n        if (!receivedMessage.isEmpty()) {\r\n          int delimiterIndex = receivedMessage.indexOf(\"::\");\r\n          if (delimiterIndex != -1) {\r\n            int headerIndex = receivedMessage.indexOf(\"::\");\r\n            String header = receivedMessage.substring(0, headerIndex);\r\n            if (header == \"POWER_SWITCH\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"OFF\") {\r\n                setMasterPowerOff();\r\n              } else if (valueString == \"STANDBY\") {\r\n                if (currentPowerState0 == 1) {\r\n                  setGameOff();\r\n                } else if (currentPowerState0 == -1 || (currentPowerState0 == 0 && currentNuPowerState0 != ((enhancedStandby == true) ? 1 : 0))) {\r\n                  setMasterPowerOn();\r\n                }\r\n              } else if (valueString == \"ON\") {\r\n                setGameOn();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + getPowerAuth());\r\n              }\r\n            } else if (header == \"POWER_REQUEST\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"OFF\") {\r\n                requestPowerOff();\r\n              } else if (valueString == \"STANDBY_NA\") {\r\n                if (currentPowerState0 == 1) {\r\n                  setGameOn();\r\n                } else if (currentPowerState0 == -1) {\r\n                  setMasterPowerOn();\r\n                }\r\n              } else if (valueString == \"STANDBY\") {\r\n                requestStandby();\r\n              } else if (valueString == \"ON\") {\r\n                setGameOn();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((requestedPowerState0 == -1) ? \"Power Off\" : (requestedPowerState0 == 0) ? \"Standby\" : \"None\"));\r\n              }\r\n            } else if (header == \"ENHANCED_STANDBY\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"DISABLE\") {\r\n                enhancedStandby = false;\r\n                if (currentPowerState0 != 1) {\r\n                  enterEnhancedStandby(false);\r\n                }\r\n              } else if (valueString == \"ENABLE\") {\r\n                enhancedStandby = true;\r\n                if (currentPowerState0 != 1) {\r\n                  enterEnhancedStandby(true);\r\n                }\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((enhancedStandby == true) ? \"Enable\" : \"Disabled\"));\r\n              }\r\n            } else if (header == \"INACTIVITY_TIMER\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"RESET\") {\r\n                resetInactivityTimer();\r\n              } else if (valueString == \"SET\") {\r\n                int timeIndex = receivedMessage.indexOf(\"::\", valueIndex + 2);\r\n                String timeString = receivedMessage.substring(valueIndex + 2, timeIndex);\r\n                int timeInt = timeString.toInt();\r\n                defaultInactivityMinTimeout = timeInt;\r\n                resetInactivityTimer();\r\n              } else if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((currentPowerState0 == 1 && inactivityTimeout == true) ? String(inactivityMinTimeout - ((millis() - previousInactivityMillis) / 1000)) : \"0\"));\r\n              }\r\n            } else if (header == \"SHUTDOWN_TIMER\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + String((currentPowerState0 == 1) ? String(shutdownDelayMinTimeout - ((millis() - previousShutdownMillis) / 1000)) : \"0\"));\r\n              }\r\n            } else if (header == \"DISK_SELECT\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"?\") {\r\n                Serial.println(\"R::\" + getGameSelect());\r\n              } else {\r\n                int valueInt = valueString.toInt();\r\n                requestedGameSelected0 = valueInt;\r\n                if (enhancedStandby == false || currentPowerState0 == 1) {\r\n                  setGameDisk(valueInt);\r\n                }\r\n              }\r\n            } else if (header == \"STATE\") {\r\n              int valueIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String valueString = receivedMessage.substring(headerIndex + 2, valueIndex);\r\n              if (valueString == \"RESET\") {\r\n                resetState();\r\n              }\r\n            } else if (header == \"VOLUME\") {\r\n              int optionIndex = receivedMessage.indexOf(\"::\", headerIndex + 2);\r\n              String optionString = receivedMessage.substring(headerIndex + 2, optionIndex);\r\n              if (optionString == \"?\") {\r\n                Serial.println(\"R::\" + ((muteVolume == true) ? \"Muted\" : String(map(currentVolume, minimumVolume, maximumVolume, 0, 100))));\r\n              } else if (optionString == \"SET\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                if (valueInt >= 0 && valueInt <= 100) {\r\n                  currentVolume = map(valueInt, 0, 100, minimumVolume, maximumVolume);\r\n                  muteVolume = false;\r\n                  ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                  displayVolumeMessage();\r\n                }\r\n              } else if (optionString == \"UP\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n                current_percent += valueInt;\r\n                currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n                muteVolume = false;\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"DOWN\") {\r\n                int valueIndex = receivedMessage.indexOf(\"::\", optionIndex + 2);\r\n                String valueString = receivedMessage.substring(optionIndex + 2, valueIndex);\r\n                int valueInt = valueString.toInt();\r\n                int current_percent = map(currentVolume, minimumVolume, maximumVolume, 0, 100);\r\n                current_percent -= valueInt;\r\n                currentVolume = map(current_percent, 0, 100, minimumVolume, maximumVolume);\r\n                muteVolume = false;\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE_ON\") {\r\n                muteVolume = true;\r\n                ds3502.setWiper(minimumVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE_OFF\") {\r\n                muteVolume = false;\r\n                ds3502.setWiper(currentVolume);\r\n                displayVolumeMessage();\r\n              } else if (optionString == \"MUTE\") {\r\n                muteVolume = !(muteVolume);\r\n                ds3502.setWiper((muteVolume == true) ? minimumVolume : currentVolume);\r\n                displayVolumeMessage();\r\n              }\r\n            } else if (header == \"PING\") {\r\n              Serial.println(\"R::PONG\");\r\n            }\r\n          }\r\n        }\r\n        receivedMessage = \"\";\r\n      } else {\r\n        receivedMessage += c;\r\n      }\r\n    }\r\n    delay(1);\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/WACCA/WACCA.ino b/WACCA/WACCA.ino
--- a/WACCA/WACCA.ino	(revision df7a14d0149c1334c5c0f2cfd9fd7d796c32b200)
+++ b/WACCA/WACCA.ino	(date 1711068220168)
@@ -1622,6 +1622,7 @@
     startingLEDState();
     setMarqueeState(true, false);
     if (enhancedStandby == true) {
+      delay(15000);
       exitEnhancedStandby();
     }
     if (requestedGameSelected0 != currentGameSelected0) {
@@ -1748,7 +1749,7 @@
   }
 }
 void exitEnhancedStandby() {
-  tone(buzzer_pin, NOTE_D4);
+  tone(buzzer_pin, NOTE_C5);
   HTTPClient http;
   String url = String(shutdown_url);
   Serial.println("Sending GET request to: " + url);
